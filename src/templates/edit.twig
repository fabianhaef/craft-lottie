{% extends "_layouts/cp" %}
{% import "_includes/forms" as forms %}

{% set title = "Edit: " ~ asset.filename %}

{% block content %}
    <div class="lottie-editor">
        <div class="lottie-editor-header">
            <div class="flex">
                <div class="flex-grow">
                    <h1>{{ asset.filename }}</h1>
                    <p class="light">{{ asset.volume.name }} • {{ asset.size|filesize }}</p>
                </div>
                <div class="flex gap">
                    <a href="{{ url('craft-lottie') }}" class="btn">{{ "← Back to Library"|t('craft-lottie') }}</a>
                    <button id="save-btn" class="btn submit" disabled>{{ "Save Changes"|t('craft-lottie') }}</button>
                </div>
            </div>
        </div>

        <div class="lottie-editor-content">
            <div class="lottie-editor-grid">
                <!-- Preview Section -->
                <div class="lottie-preview-pane">
                    <div class="pane">
                        <h2>{{ "Preview"|t('craft-lottie') }}</h2>
                        <div id="lottie-preview" class="lottie-preview-container" data-asset-id="{{ asset.id }}">
                            <div class="lottie-loading">
                                <div class="spinner"></div>
                                <p>{{ "Loading animation..."|t('craft-lottie') }}</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Controls Section -->
                <div class="lottie-controls-pane">
                    <div class="pane">
                        <h2>{{ "Animation Settings"|t('craft-lottie') }}</h2>
                        
                        {% set speedLabel = "Playback Speed"|t('craft-lottie') %}
                        {% set speedInstructions = "Adjust the animation playback speed (0.1x to 5.0x)"|t('craft-lottie') %}
                        {{ forms.field({
                            label: speedLabel,
                            instructions: speedInstructions,
                            id: 'speed-field'
                        }, '<div class="lottie-speed-control-wrapper">
                            <input type="range" id="speed-control" min="0.1" max="5" step="0.1" value="1.0" class="lottie-speed-slider">
                            <div class="lottie-speed-display">
                                <input type="number" id="speed-input" min="0.1" max="5" step="0.1" value="1.0" class="lottie-speed-input">
                                <span class="lottie-speed-unit">x</span>
                            </div>
                        </div>') }}

                        {% set bgColorLabel = "Background Color"|t('craft-lottie') %}
                        {% set bgColorInstructions = "Set a background color for the animation preview"|t('craft-lottie') %}
                        {% set clearLabel = "Clear"|t('craft-lottie') %}
                        {{ forms.field({
                            label: bgColorLabel,
                            instructions: bgColorInstructions,
                            id: 'background-color-field'
                        }, '<div class="lottie-background-control-wrapper">
                            <input type="color" id="background-color" value="#ffffff" class="lottie-color-input">
                            <button type="button" id="clear-background" class="btn small">' ~ clearLabel ~ '</button>
                        </div>') }}

                        {% set colorsLabel = "Edit Colors"|t('craft-lottie') %}
                        {% set colorsInstructions = "Modify colors in the animation. Changes are applied in real-time."|t('craft-lottie') %}
                        {% set extractingColors = "Extracting colors..."|t('craft-lottie') %}
                        {{ forms.field({
                            label: colorsLabel,
                            instructions: colorsInstructions,
                            id: 'colors-field'
                        }, '<div id="color-picker-container" class="lottie-color-picker-container">
                            <div class="lottie-colors-loading">' ~ extractingColors ~ '</div>
                        </div>') }}

                        {% set textLabel = "Edit Text"|t('craft-lottie') %}
                        {% set textInstructions = "Modify text content in the animation. Changes are applied in real-time."|t('craft-lottie') %}
                        {% set extractingText = "Extracting text layers..."|t('craft-lottie') %}
                        {{ forms.field({
                            label: textLabel,
                            instructions: textInstructions,
                            id: 'text-editor-field'
                        }, '<div id="text-editor-container" class="lottie-text-editor-container">
                            <div class="lottie-text-loading">' ~ extractingText ~ '</div>
                        </div>') }}

                        {% set layersLabel = "Layer Management"|t('craft-lottie') %}
                        {% set layersInstructions = "Show or hide layers in the animation. Changes are applied in real-time."|t('craft-lottie') %}
                        {% set extractingLayers = "Extracting layers..."|t('craft-lottie') %}
                        {{ forms.field({
                            label: layersLabel,
                            instructions: layersInstructions,
                            id: 'layers-field'
                        }, '<div id="layers-container" class="lottie-layers-container">
                            <div class="lottie-layers-loading">' ~ extractingLayers ~ '</div>
                        </div>') }}
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% css %}
.lottie-editor-header {
    margin-bottom: 24px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--hairline-color);
}

.lottie-editor-header h1 {
    margin-bottom: 4px;
    font-size: 24px;
}

.lottie-editor-header .flex {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.lottie-editor-header .flex.gap {
    gap: 12px;
}

.lottie-editor-content {
    max-width: 1400px;
}

.lottie-editor-grid {
    display: grid;
    grid-template-columns: 1fr 400px;
    gap: 24px;
}

.lottie-preview-pane .pane,
.lottie-controls-pane .pane {
    padding: 24px;
    background: var(--pane-bg);
    border-radius: var(--pane-border-radius);
    box-shadow: var(--pane-shadow);
}

.lottie-preview-pane h2,
.lottie-controls-pane h2 {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 16px;
    color: var(--text-color);
}

.lottie-preview-container {
    width: 100%;
    min-height: 400px;
    max-height: 600px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.lottie-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    color: var(--light-text-color);
}

.lottie-loading .spinner {
    width: 32px;
    height: 32px;
    border: 3px solid var(--gray-200);
    border-top-color: var(--link-color);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.lottie-speed-control-wrapper {
    display: flex;
    align-items: center;
    gap: 16px;
}

.lottie-speed-slider {
    flex: 1;
    height: 6px;
    border-radius: 3px;
    background: var(--gray-200);
    outline: none;
    -webkit-appearance: none;
    cursor: pointer;
}

.lottie-speed-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--link-color);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s;
}

.lottie-speed-slider::-webkit-slider-thumb:hover {
    transform: scale(1.1);
}

.lottie-speed-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--link-color);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s;
}

.lottie-speed-slider::-moz-range-thumb:hover {
    transform: scale(1.1);
}

.lottie-speed-display {
    display: flex;
    align-items: center;
    gap: 4px;
    min-width: 80px;
}

.lottie-speed-input {
    width: 60px;
    padding: 6px 8px;
    border: 1px solid var(--input-border-color);
    border-radius: var(--small-border-radius);
    background: var(--input-bg);
    font-size: 14px;
    text-align: center;
}

.lottie-speed-unit {
    font-size: 14px;
    color: var(--light-text-color);
    font-weight: 500;
}

.lottie-background-control-wrapper {
    display: flex;
    align-items: center;
    gap: 12px;
}

.lottie-color-input {
    width: 60px;
    height: 40px;
    border: 1px solid var(--input-border-color);
    border-radius: var(--small-border-radius);
    cursor: pointer;
    padding: 2px;
    background: var(--input-bg);
}

.lottie-color-picker-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
    margin-top: 8px;
}

.lottie-color-item {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    transition: all 0.2s;
}

.lottie-color-item:hover {
    border-color: var(--link-color);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.lottie-color-swatch {
    width: 100%;
    height: 40px;
    border-radius: var(--small-border-radius);
    border: 1px solid var(--hairline-color);
    cursor: pointer;
    padding: 2px;
    background: white;
}

.lottie-color-label {
    font-size: 12px;
    color: var(--light-text-color);
    text-align: center;
    word-break: break-all;
}

.lottie-colors-loading {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
}

.lottie-colors-empty {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
    font-style: italic;
}

.lottie-text-editor-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 8px;
}

.lottie-text-loading {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
}

.lottie-text-empty {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
    font-style: italic;
}

.lottie-text-item {
    padding: 12px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    transition: all 0.2s;
}

.lottie-text-item:hover {
    border-color: var(--link-color);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.lottie-text-header {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--hairline-color);
}

.lottie-text-input-wrapper {
    margin-top: 8px;
}

.lottie-text-input-wrapper:first-of-type {
    margin-top: 0;
}

.lottie-text-label {
    display: block;
    font-size: 12px;
    color: var(--light-text-color);
    margin-bottom: 4px;
}

.lottie-text-input {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid var(--input-border-color);
    border-radius: var(--small-border-radius);
    background: var(--input-bg);
    font-size: 14px;
    transition: border-color 0.2s;
}

.lottie-text-input:focus {
    outline: none;
    border-color: var(--link-color);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.lottie-layers-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
    max-height: 400px;
    overflow-y: auto;
}

.lottie-layers-loading {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
}

.lottie-layers-empty {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
    font-style: italic;
}

.lottie-layer-item {
    padding: 10px 12px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    transition: all 0.2s;
}

.lottie-layer-item:hover {
    border-color: var(--link-color);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.lottie-layer-toggle {
    display: flex;
    align-items: center;
    cursor: pointer;
    user-select: none;
}

.lottie-layer-toggle-label {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
}

.lottie-layer-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
    flex-shrink: 0;
}

.lottie-layer-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.lottie-layer-name {
    font-size: 13px;
    font-weight: 500;
    color: var(--text-color);
}

.lottie-layer-type {
    font-size: 11px;
    color: var(--light-text-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.lottie-layer-item:has(.lottie-layer-checkbox:not(:checked)) {
    opacity: 0.6;
}

.lottie-layer-item:has(.lottie-layer-checkbox:not(:checked)) .lottie-layer-name {
    text-decoration: line-through;
}

.lottie-error {
    padding: 24px;
    text-align: center;
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-radius: var(--small-border-radius);
}

.lottie-error > div:first-child {
    color: #cf1124;
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 8px;
}

.lottie-error > div:nth-child(2) {
    color: #6b7280;
    font-size: 14px;
    margin-bottom: 16px;
}

.lottie-error > div:last-child {
    font-size: 12px;
    color: #9ca3af;
}

@media (max-width: 1200px) {
    .lottie-editor-grid {
        grid-template-columns: 1fr;
    }
    
    .lottie-controls-pane {
        order: -1;
    }
}
{% endcss %}

{% js %}
// Load lottie-web library dynamically
// Using version 5.9.6 which is more stable with minimal text layer structures
const lottieScript = document.createElement('script');
lottieScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.9.6/lottie.min.js';
console.log('[DEBUG-I] Loading lottie-web version 5.9.6 instead of 5.12.2');
lottieScript.onload = function() {
    initLottieEditor();
};
lottieScript.onerror = function() {
    const previewContainer = document.getElementById('lottie-preview');
    if (previewContainer) {
        previewContainer.innerHTML = '<div class="lottie-loading"><p style="color: #cf1124;">Failed to load Lottie library. Please refresh the page.</p></div>';
    }
};
document.head.appendChild(lottieScript);

function initLottieEditor() {
    const previewContainer = document.getElementById('lottie-preview');
    const speedControl = document.getElementById('speed-control');
    const speedInput = document.getElementById('speed-input');
    const colorContainer = document.getElementById('color-picker-container');
    const backgroundColorInput = document.getElementById('background-color');
    const clearBackgroundBtn = document.getElementById('clear-background');

    // Get asset ID from data attribute
    const assetId = previewContainer.getAttribute('data-asset-id');

    if (!assetId) {
        previewContainer.innerHTML = '<div class="lottie-loading"><p style="color: #cf1124;">Invalid asset ID</p></div>';
        return;
    }

    let lottieAnimation = null;
    let lottieData = null;
    let hasChanges = false;
    let backgroundColor = null;

    const saveBtn = document.getElementById('save-btn');

    // Load the Lottie file via controller action
    const fetchUrl = '/actions/craft-lottie/default/get-asset-json?assetId=' + assetId;

    fetch(fetchUrl)
        .then(response => {
            if (!response.ok) {
                // Try to get error details from response
                return response.json().then(data => {
                    throw new Error(data.error || 'HTTP ' + response.status + ': ' + response.statusText);
                }).catch(() => {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                });
            }
            return response.json();
        })
        .then(data => {
            // #region agent log
            console.log('[DEBUG-RAW] Raw data received from server:', data);
            console.log('[DEBUG-RAW] data.animation exists:', !!data.animation);
            console.log('[DEBUG-RAW] data type:', typeof data);
            // #endregion
            
            if (data.error) {
                const errorCode = data.errorCode || 'UNKNOWN_ERROR';
                const errorMessage = data.error || 'An unknown error occurred';
                console.error('Lottie load error:', errorCode, errorMessage);
                showError(errorMessage, errorCode);
                return;
            }
            
            lottieData = data.animation || data;
            // #region agent log
            console.log('[DEBUG-RAW] lottieData after assignment:', lottieData);
            console.log('[DEBUG-RAW] Text layer t property:', lottieData?.layers?.find(l => l.ty === 5)?.t);
            // #endregion
            backgroundColor = data.backgroundColor || null;
            const savedSpeed = data.speed || 1.0;

            if (backgroundColor) {
                backgroundColorInput.value = backgroundColor;
            }
            
            if (speedControl && speedInput) {
                speedControl.value = savedSpeed;
                speedInput.value = savedSpeed;
            }

            // Validate data structure before proceeding
            if (!lottieData || typeof lottieData !== 'object') {
                showError('Invalid animation data structure', 'INVALID_DATA');
                return;
            }
            
            // #region agent log
            const textLayersOnLoad = (lottieData.layers||[]).filter(l=>l.ty===5).map(l=>({nm:l.nm,tStructure:l.t?{hasD:!!l.t.d,dHasK:!!l.t.d?.k,kType:l.t.d?.k?typeof l.t.d.k:'none',kIsArray:Array.isArray(l.t.d?.k),kLength:Array.isArray(l.t.d?.k)?l.t.d.k.length:null,firstKHasS:Array.isArray(l.t.d?.k)?!!l.t.d.k[0]?.s:!!l.t.d?.k?.s}:null}));
            console.log('[DEBUG-D] Lottie data loaded - text layer structure', {textLayersOnLoad, totalLayers:lottieData.layers?.length});
            // #endregion
            
            renderAnimation();
            extractColors();
            extractTextLayers();
            extractLayers();
        })
        .catch(error => {
            console.error('Failed to load Lottie file:', error);
            // Try to get error details from response if available
            if (error.response) {
                error.response.json().then(data => {
                    if (data.error) {
                        showError(data.error, data.errorCode || 'NETWORK_ERROR');
                    } else {
                        showError(error.message || 'An unexpected error occurred while loading the animation.', 'NETWORK_ERROR');
                    }
                }).catch(() => {
                    showError(error.message || 'An unexpected error occurred while loading the animation.', 'NETWORK_ERROR');
                });
            } else {
                showError(error.message || 'An unexpected error occurred while loading the animation.', 'NETWORK_ERROR');
            }
        });

    function showError(message, errorCode = 'ERROR') {
        const errorHtml = `
            <div class="lottie-error" style="padding: 24px; text-align: center;">
                <div style="color: #cf1124; font-size: 18px; font-weight: 600; margin-bottom: 8px;">
                    Unable to load animation
                </div>
                <div style="color: #6b7280; font-size: 14px; margin-bottom: 16px;">
                    ${escapeHtml(message)}
                </div>
                <div style="font-size: 12px; color: #9ca3af;">
                    Error code: ${errorCode}
                </div>
            </div>
        `;
        previewContainer.innerHTML = errorHtml;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function renderAnimation() {
        // #region agent log
        console.log('[DEBUG-D] renderAnimation called', {hasLottieData:!!lottieData, layerCount:lottieData?.layers?.length});
        // #endregion
        if (lottieAnimation) {
            try {
                lottieAnimation.destroy();
            } catch (e) {
                // Ignore destroy errors
            }
            lottieAnimation = null;
        }

        // Clear loading state
        previewContainer.innerHTML = '';

        // Apply background color
        if (backgroundColor) {
            previewContainer.style.backgroundColor = backgroundColor;
        } else {
            previewContainer.style.backgroundColor = '';
        }

        if (!lottieData) {
            previewContainer.innerHTML = '<div class="lottie-loading"><p style="color: #cf1124;">No animation data available</p></div>';
            return;
        }

        try {
            // Create a clean copy without our internal flags
            const animationDataCopy = JSON.parse(JSON.stringify(lottieData));
            
            // #region agent log
            const textLayersBefore = (animationDataCopy.layers||[]).filter(l=>l.ty===5).map(l=>({nm:l.nm,hasT:!!l.t,hasTD:!!l.t?.d,tdkType:l.t?.d?.k?typeof l.t.d.k:'none',tdkIsArray:Array.isArray(l.t?.d?.k),tdkKeys:l.t?.d?.k&&typeof l.t.d.k==='object'&&!Array.isArray(l.t.d.k)?Object.keys(l.t.d.k):['array:'+l.t?.d?.k?.length],tdHasA:l.t?.d?.a!==undefined}));
            console.log('[DEBUG-B] Text layers BEFORE fixKeyframeStructures', textLayersBefore);
            // #endregion
            
            // Remove our internal flags before rendering
            cleanLottieData(animationDataCopy);
            
            // #region agent log - FIX: Add missing required properties to text layers
            // Text layers need t.p, t.m, and t.a to work properly with lottie-web
            if (animationDataCopy.layers && Array.isArray(animationDataCopy.layers)) {
                animationDataCopy.layers.forEach((layer, idx) => {
                    if (layer.ty === 5 && layer.t) {
                        console.log(`[DEBUG-FIX] Fixing text layer ${idx}, current t keys:`, Object.keys(layer.t));
                        
                        // Add empty text path if missing
                        if (!layer.t.p) {
                            layer.t.p = {};
                            console.log(`[DEBUG-FIX] Added empty t.p to layer ${idx}`);
                        }
                        
                        // Add text more options if missing
                        if (!layer.t.m) {
                            layer.t.m = {
                                g: 1,
                                a: { a: 0, k: [0, 0], ix: 2 }
                            };
                            console.log(`[DEBUG-FIX] Added t.m to layer ${idx}`);
                        }
                        
                        // Add empty text animators array if missing
                        if (!layer.t.a) {
                            layer.t.a = [];
                            console.log(`[DEBUG-FIX] Added empty t.a array to layer ${idx}`);
                        }
                        
                        console.log(`[DEBUG-FIX] Fixed text layer ${idx}, new t keys:`, Object.keys(layer.t));
                    }
                });
            }
            // #endregion
            
            // Re-enable keyframe structure fixes
            fixKeyframeStructures(animationDataCopy);
            
            // #region agent log
            const textLayersAfter = (animationDataCopy.layers||[]).filter(l=>l.ty===5).map(l=>({nm:l.nm,hasT:!!l.t,hasTD:!!l.t?.d,tdkType:l.t?.d?.k?typeof l.t.d.k:'none',tdkIsArray:Array.isArray(l.t?.d?.k),tdHasA:l.t?.d?.a!==undefined,tdA:l.t?.d?.a}));
            console.log('[DEBUG-B] Text layers AFTER fixKeyframeStructures', textLayersAfter);
            // #endregion
            
            // Apply layer visibility by filtering layers (safer than modifying op)
            if (animationDataCopy.layers && Array.isArray(animationDataCopy.layers) && lottieData.layers) {
                // Filter out hidden layers for preview
                animationDataCopy.layers = animationDataCopy.layers.filter((layer, index) => {
                    const originalLayer = lottieData.layers[index];
                    if (originalLayer && originalLayer._hidden === true) {
                        return false; // Hide this layer
                    }
                    return true; // Show this layer
                });
            }
            
            // #region agent log
            console.log('[DEBUG-D] About to call lottie.loadAnimation', {finalLayerCount:animationDataCopy.layers?.length, hasV:!!animationDataCopy.v, hasFr:!!animationDataCopy.fr});
            
            // Dump ALL layers to inspect for issues
            console.log('[DEBUG-G] Full layer inspection:');
            (animationDataCopy.layers||[]).forEach((layer, idx) => {
                const layerInfo = {
                    idx,
                    nm: layer.nm,
                    ty: layer.ty,
                    hasKs: !!layer.ks,
                    ksKeys: layer.ks ? Object.keys(layer.ks) : [],
                    // Check each transform property for issues
                    ks_o: layer.ks?.o ? {a: layer.ks.o.a, hasK: layer.ks.o.k !== undefined} : 'MISSING',
                    ks_r: layer.ks?.r ? {a: layer.ks.r.a, hasK: layer.ks.r.k !== undefined} : 'MISSING',
                    ks_p: layer.ks?.p ? {a: layer.ks.p.a, hasK: layer.ks.p.k !== undefined} : 'MISSING',
                    ks_a: layer.ks?.a ? {a: layer.ks.a.a, hasK: layer.ks.a.k !== undefined} : 'MISSING',
                    ks_s: layer.ks?.s ? {a: layer.ks.s.a, hasK: layer.ks.s.k !== undefined} : 'MISSING',
                    // Check for parent reference
                    parent: layer.parent,
                    // For text layers, check t structure
                    hasT: layer.ty === 5 ? !!layer.t : 'N/A',
                    t_keys: layer.ty === 5 && layer.t ? Object.keys(layer.t) : 'N/A'
                };
                console.log(`[DEBUG-G] Layer ${idx}:`, layerInfo);
            });
            
            // Check assets too
            console.log('[DEBUG-G] Assets:', animationDataCopy.assets?.length || 0, 'assets');
            // #endregion
            
            lottieAnimation = lottie.loadAnimation({
                container: previewContainer,
                renderer: 'svg',
                loop: true,
                autoplay: true,
                animationData: animationDataCopy
            });

            // Apply speed
            const speed = parseFloat(speedControl.value) || 1.0;
            if (!isNaN(speed) && speed > 0) {
                lottieAnimation.setSpeed(speed);
            } else {
                lottieAnimation.setSpeed(1.0);
            }
        } catch (error) {
            // #region agent log
            console.log('[DEBUG-D] Error in renderAnimation', {errorMsg:error.message, errorName:error.name, stack:error.stack});
            // #endregion
            console.error('Error rendering animation:', error);
            console.error('Error details:', {
                message: error.message,
                stack: error.stack,
                name: error.name
            });
            console.error('Lottie data keys:', lottieData ? Object.keys(lottieData) : 'null');
            showError('Error rendering animation: ' + error.message, 'RENDER_ERROR');
        }
    }

    function fixKeyframeStructures(obj, path = '') {
        // Recursively fix keyframe structures that might be missing 'a' property
        if (Array.isArray(obj)) {
            obj.forEach((item, idx) => fixKeyframeStructures(item, `${path}[${idx}]`));
        } else if (obj && typeof obj === 'object' && obj !== null) {
            // Check if this looks like an animated property (has 'k' but missing 'a')
            // BUT skip text document data (t.d) which has 'k' as keyframe array, not animated value
            if (obj.k !== undefined && obj.a === undefined) {
                // #region agent log
                console.log('[DEBUG-B] fixKeyframeStructures: Found k without a', {path, objKeys:Object.keys(obj), kType:typeof obj.k, kIsArray:Array.isArray(obj.k)});
                // #endregion
                
                // Skip if this looks like text document data (t.d)
                // Text document 'k' is an array of keyframes with 's' (style) and 't' (time) properties
                const isTextDocumentData = Array.isArray(obj.k) && obj.k.length > 0 && 
                    obj.k[0] && typeof obj.k[0] === 'object' && 
                    (obj.k[0].s !== undefined || obj.k[0].t !== undefined);
                
                if (isTextDocumentData) {
                    // #region agent log
                    console.log('[DEBUG-B] SKIPPING text document data - not adding a=0', {path});
                    // #endregion
                    // Don't add 'a' to text document data
                } else {
                    // #region agent log
                    console.log('[DEBUG-B] Adding a=0 to animated property', {path});
                    // #endregion
                    // Assume it's not animated if 'a' is missing
                    obj.a = 0;
                }
            }
            
            // Check common keyframe properties in transforms (ks object)
            if (obj.ks && typeof obj.ks === 'object') {
                const keyframeProps = ['o', 'r', 'p', 'a', 's', 't', 'sk', 'sa', 'sc', 'sw', 'rx', 'ry', 'rz', 'or'];
                for (const prop of keyframeProps) {
                    if (obj.ks[prop] && typeof obj.ks[prop] === 'object') {
                        if (obj.ks[prop].k !== undefined && obj.ks[prop].a === undefined) {
                            obj.ks[prop].a = 0;
                        }
                        // Fix nested keyframe arrays
                        if (Array.isArray(obj.ks[prop].k)) {
                            obj.ks[prop].k.forEach((kf, idx) => {
                                if (kf && typeof kf === 'object' && kf.s !== undefined && kf.s !== null) {
                                    // Keyframe has a value, ensure it's valid
                                    if (typeof kf.s === 'object' && kf.s.a === undefined && kf.s.k !== undefined) {
                                        kf.s.a = 0;
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            // Fix shape properties
            if (Array.isArray(obj.shapes)) {
                obj.shapes.forEach((shape, idx) => {
                    if (shape && typeof shape === 'object') {
                        // Fix shape transform properties
                        if (shape.p && typeof shape.p === 'object' && shape.p.k !== undefined && shape.p.a === undefined) {
                            shape.p.a = 0;
                        }
                        if (shape.s && typeof shape.s === 'object' && shape.s.k !== undefined && shape.s.a === undefined) {
                            shape.s.a = 0;
                        }
                        // Fix color properties
                        if (shape.c && typeof shape.c === 'object' && shape.c.k !== undefined && shape.c.a === undefined) {
                            shape.c.a = 0;
                        }
                        if (shape.o && typeof shape.o === 'object' && shape.o.k !== undefined && shape.o.a === undefined) {
                            shape.o.a = 0;
                        }
                    }
                });
            }
            
            // Recursively process nested objects
            for (const key in obj) {
                if (obj.hasOwnProperty(key) && typeof obj[key] === 'object' && obj[key] !== null) {
                    fixKeyframeStructures(obj[key], path ? `${path}.${key}` : key);
                }
            }
        }
    }

    function cleanLottieData(obj) {
        // Recursively remove our internal flags (_hidden, _originalOp)
        if (Array.isArray(obj)) {
            obj.forEach(item => cleanLottieData(item));
        } else if (obj && typeof obj === 'object') {
            // Remove internal flags but keep the structure
            delete obj._hidden;
            // Keep _originalOp for now as we need it for restoration
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    cleanLottieData(obj[key]);
                }
            }
        }
    }


    // Speed control synchronization
    function syncSpeed(value) {
        if (speedControl) speedControl.value = value;
        if (speedInput) speedInput.value = value;
        if (lottieAnimation) {
            const speed = parseFloat(value) || 1.0;
            lottieAnimation.setSpeed(speed);
        }
        markAsChanged();
    }

    speedControl.addEventListener('input', function() {
        syncSpeed(this.value);
    });

    speedInput.addEventListener('input', function() {
        let value = parseFloat(this.value);
        if (isNaN(value) || value < 0.1) value = 0.1;
        if (value > 5.0) value = 5.0;
        this.value = value;
        syncSpeed(value);
    });

    speedInput.addEventListener('blur', function() {
        if (!this.value || parseFloat(this.value) <= 0) {
            this.value = 1.0;
            syncSpeed(1.0);
        }
    });

    // Background color control
    backgroundColorInput.addEventListener('input', function(e) {
        backgroundColor = e.target.value;
        if (previewContainer) {
            previewContainer.style.backgroundColor = backgroundColor;
        }
        markAsChanged();
    });

    clearBackgroundBtn.addEventListener('click', function() {
        backgroundColor = null;
        backgroundColorInput.value = '#ffffff';
        if (previewContainer) {
            previewContainer.style.backgroundColor = '';
        }
        markAsChanged();
    });

    // Extract text layers from Lottie JSON
    function extractTextLayers() {
        const textContainer = document.getElementById('text-editor-container');
        if (!textContainer) return;

        const textLayers = [];
        findTextLayers(lottieData, textLayers);

        textContainer.innerHTML = '';

        if (textLayers.length === 0) {
            textContainer.innerHTML = '<div class="lottie-text-empty">{{ "No editable text layers found in this animation"|t('craft-lottie') }}</div>';
            return;
        }

        textLayers.forEach((textLayer, index) => {
            createTextEditor(textLayer, index);
        });
    }

    function findTextLayers(obj, textLayers, layerPath = '', layerIndex = 0) {
        if (typeof obj !== 'object' || obj === null) return;

        // Recursively search in layers array first (most common structure)
        if (Array.isArray(obj.layers)) {
            obj.layers.forEach((layer, index) => {
                const currentPath = layerPath ? `${layerPath}.layers[${index}]` : `layers[${index}]`;
                findTextLayers(layer, textLayers, currentPath, index);
            });
            return; // Don't process layers array itself as a text layer
        }

        // Check if this is a layer with text (ty === 5 means text layer)
        if (obj.ty === 5 && obj.t) {
            const textData = obj.t;
            let texts = [];

            // Handle different text data structures
            // Structure: t.d.k[].s.t (keyframed) or t.d.k.s.t (static)
            if (textData.d && textData.d.k) {
                if (Array.isArray(textData.d.k)) {
                    // Keyframed text: k is an array of keyframes
                    textData.d.k.forEach((keyframe, kIndex) => {
                        if (keyframe.s && typeof keyframe.s.t === 'string') {
                            texts.push({
                                text: keyframe.s.t,
                                keyframeIndex: kIndex,
                                isKeyframed: true,
                                keyframeData: keyframe
                            });
                        }
                    });
                } else if (textData.d.k.s && typeof textData.d.k.s.t === 'string') {
                    // Single keyframe or static text
                    texts.push({
                        text: textData.d.k.s.t,
                        keyframeIndex: 0,
                        isKeyframed: Array.isArray(textData.d.k) === false,
                        keyframeData: textData.d.k
                    });
                }
            }

            if (texts.length > 0) {
                textLayers.push({
                    layerIndex: layerIndex,
                    layerName: obj.nm || `Text Layer ${textLayers.length + 1}`,
                    layerPath: layerPath,
                    texts: texts,
                    layerData: obj
                });
            }
        }
    }

    function createTextEditor(textLayer, index) {
        const textItem = document.createElement('div');
        textItem.className = 'lottie-text-item';
        textItem.dataset.layerIndex = textLayer.layerIndex;
        textItem.dataset.layerPath = textLayer.layerPath;

        const textHeader = document.createElement('div');
        textHeader.className = 'lottie-text-header';
        textHeader.textContent = textLayer.layerName;

        textItem.appendChild(textHeader);

        // Create input for each text in the layer
        textLayer.texts.forEach((textObj, textIndex) => {
            const textInputWrapper = document.createElement('div');
            textInputWrapper.className = 'lottie-text-input-wrapper';

            const textLabel = document.createElement('label');
            textLabel.className = 'lottie-text-label';
            if (textLayer.texts.length > 1) {
                textLabel.textContent = `{{ "Text"|t('craft-lottie') }} ${textIndex + 1}${textObj.isKeyframed ? ' ({{ "Keyframe"|t('craft-lottie') }} ' + (textObj.keyframeIndex + 1) + ')' : ''}`;
            } else {
                textLabel.textContent = '{{ "Text Content"|t('craft-lottie') }}';
            }

            const textInput = document.createElement('input');
            textInput.type = 'text';
            textInput.className = 'lottie-text-input';
            textInput.value = textObj.text;
            textInput.dataset.textIndex = textIndex;
            textInput.dataset.keyframeIndex = textObj.keyframeIndex;
            textInput.dataset.isKeyframed = textObj.isKeyframed;

            textInput.addEventListener('input', function() {
                updateText(textLayer, textIndex, this.value);
            });

            textInputWrapper.appendChild(textLabel);
            textInputWrapper.appendChild(textInput);
            textItem.appendChild(textInputWrapper);
        });

        document.getElementById('text-editor-container').appendChild(textItem);
    }

    function updateText(textLayer, textIndex, newText) {
        // #region agent log
        console.log('[DEBUG-A] updateText called', {layerPath:textLayer.layerPath, textIndex, newText, layerName:textLayer.layerName});
        // #endregion
        const layer = getLayerByPath(lottieData, textLayer.layerPath);
        // #region agent log
        console.log('[DEBUG-C] Layer lookup result', {layerFound:!!layer, hasT:layer?.t!==undefined, hasTD:layer?.t?.d!==undefined, layerPath:textLayer.layerPath, tdkType:layer?.t?.d?.k?typeof layer.t.d.k:'none', tdkIsArray:Array.isArray(layer?.t?.d?.k)});
        // #endregion
        if (!layer || !layer.t || !layer.t.d) {
            console.warn('Could not find layer at path:', textLayer.layerPath);
            return;
        }

        const textObj = textLayer.texts[textIndex];
        
        // Update the text in the JSON structure
        if (Array.isArray(layer.t.d.k)) {
            // Keyframed text: update specific keyframe
            const keyframe = layer.t.d.k[textObj.keyframeIndex];
            // #region agent log
            console.log('[DEBUG-A] Updating keyframed text', {keyframeIndex:textObj.keyframeIndex, keyframeExists:!!keyframe, keyframeHasS:keyframe?.s!==undefined, beforeText:keyframe?.s?.t});
            // #endregion
            if (keyframe && keyframe.s) {
                keyframe.s.t = newText;
            }
        } else if (layer.t.d.k && layer.t.d.k.s) {
            // Static text or single keyframe
            // #region agent log
            console.log('[DEBUG-A] Updating static text', {beforeText:layer.t.d.k.s.t, tdkStructure:Object.keys(layer.t.d.k)});
            // #endregion
            layer.t.d.k.s.t = newText;
        }

        // Update the text in our textLayer object for UI consistency
        textObj.text = newText;

        renderAnimation();
        markAsChanged();
    }

    function getLayerByPath(obj, path) {
        if (!path) return obj;
        
        // Handle paths like "layers[0]" or "layers[0].layers[1]"
        const parts = path.split('.');
        let current = obj;
        
        for (const part of parts) {
            const arrayMatch = part.match(/^(\w+)\[(\d+)\]$/);
            if (arrayMatch) {
                const [, key, index] = arrayMatch;
                if (current && current[key] && Array.isArray(current[key])) {
                    const idx = parseInt(index);
                    if (idx >= 0 && idx < current[key].length) {
                        current = current[key][idx];
                    } else {
                        console.warn(`Index ${idx} out of bounds for ${key}`);
                        return null;
                    }
                } else {
                    console.warn(`Could not access ${key}[${index}]`);
                    return null;
                }
            } else {
                if (current && current[part]) {
                    current = current[part];
                } else {
                    console.warn(`Could not access property ${part}`);
                    return null;
                }
            }
        }
        
        return current;
    }

    // Extract and manage layers
    function extractLayers() {
        const layersContainer = document.getElementById('layers-container');
        if (!layersContainer) return;

        if (!lottieData || !lottieData.layers || !Array.isArray(lottieData.layers)) {
            layersContainer.innerHTML = '<div class="lottie-layers-empty">{{ "No layers found in this animation"|t('craft-lottie') }}</div>';
            return;
        }

        layersContainer.innerHTML = '';

        // Process layers in reverse order (top to bottom in UI, but maintain layer order)
        const layers = [...lottieData.layers].reverse();
        
        layers.forEach((layer, index) => {
            const originalIndex = lottieData.layers.length - 1 - index;
            createLayerControl(layer, originalIndex);
        });
    }

    function createLayerControl(layer, layerIndex) {
        const layerItem = document.createElement('div');
        layerItem.className = 'lottie-layer-item';
        layerItem.dataset.layerIndex = layerIndex;

        // Determine if layer is visible
        // Check _hidden flag first, then check op > ip
        const layerIp = layer.ip !== undefined ? layer.ip : 0;
        const layerOp = layer.op !== undefined ? layer.op : (lottieData.op || 60);
        const isVisible = layer._hidden === undefined ? (layerOp > layerIp) : !layer._hidden;

        const layerToggle = document.createElement('label');
        layerToggle.className = 'lottie-layer-toggle';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = isVisible;
        checkbox.className = 'lottie-layer-checkbox';
        
        const toggleLabel = document.createElement('span');
        toggleLabel.className = 'lottie-layer-toggle-label';
        
        const layerInfo = document.createElement('div');
        layerInfo.className = 'lottie-layer-info';
        
        const layerName = document.createElement('div');
        layerName.className = 'lottie-layer-name';
        layerName.textContent = layer.nm || `Layer ${layerIndex + 1}`;
        
        const layerType = document.createElement('div');
        layerType.className = 'lottie-layer-type';
        layerType.textContent = getLayerTypeName(layer.ty);

        layerInfo.appendChild(layerName);
        layerInfo.appendChild(layerType);

        toggleLabel.appendChild(checkbox);
        toggleLabel.appendChild(layerInfo);
        layerToggle.appendChild(toggleLabel);

        checkbox.addEventListener('change', function() {
            toggleLayerVisibility(layerIndex, this.checked);
        });

        layerItem.appendChild(layerToggle);
        document.getElementById('layers-container').appendChild(layerItem);
    }

    function getLayerTypeName(type) {
        const types = {
            0: 'Precomp',
            1: 'Solid',
            2: 'Image',
            3: 'Null',
            4: 'Shape',
            5: 'Text',
            6: 'Audio',
            13: 'Camera'
        };
        return types[type] || `Type ${type}`;
    }

    function toggleLayerVisibility(layerIndex, visible) {
        if (!lottieData.layers || !lottieData.layers[layerIndex]) {
            console.warn('Layer not found at index:', layerIndex);
            return;
        }

        const layer = lottieData.layers[layerIndex];
        const animationOp = lottieData.op || 60;
        const layerIp = layer.ip !== undefined ? layer.ip : 0;
        
        // Store original op if not already stored
        if (!layer._originalOp) {
            layer._originalOp = layer.op !== undefined ? layer.op : animationOp;
        }

        // Store visibility state
        layer._hidden = !visible;

        // Re-render with updated visibility
        renderAnimation();
        markAsChanged();
    }

    // Extract colors from Lottie JSON
    function extractColors() {
        const colors = new Set();
        findColors(lottieData, colors);

        colorContainer.innerHTML = '';

        if (colors.size === 0) {
            colorContainer.innerHTML = '<div class="lottie-colors-empty">{{ "No editable colors found in this animation"|t('craft-lottie') }}</div>';
            return;
        }

        Array.from(colors).forEach((color, index) => {
            createColorPicker(color, index);
        });
    }

    function findColors(obj, colors, path = '') {
        if (typeof obj !== 'object' || obj === null) return;

        for (const key in obj) {
            const value = obj[key];

            // Look for color arrays: 'c', 's' (stroke), 'fc' (fill color)
            if (['c', 's', 'fc'].includes(key) && Array.isArray(value)) {
                // Check if it's a keyframed color (has 'k' property)
                if (value.k && Array.isArray(value.k) && value.k.length >= 3) {
                    const colorHex = rgbArrayToHex(value.k);
                    colors.add(colorHex);
                }
                // Check if it's a direct color array
                else if (value.length >= 3 && typeof value[0] === 'number') {
                    const colorHex = rgbArrayToHex(value);
                    colors.add(colorHex);
                }
            }
            // Recursively search nested objects
            else if (typeof value === 'object') {
                findColors(value, colors, path ? `${path}.${key}` : key);
            }
        }
    }

    function rgbArrayToHex(rgbArray) {
        const r = Math.round(rgbArray[0] * 255);
        const g = Math.round(rgbArray[1] * 255);
        const b = Math.round(rgbArray[2] * 255);
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    function hexToRgbArray(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16) / 255,
            parseInt(result[2], 16) / 255,
            parseInt(result[3], 16) / 255
        ] : null;
    }

    function createColorPicker(color, index) {
        const colorItem = document.createElement('div');
        colorItem.className = 'lottie-color-item';

        const colorSwatch = document.createElement('input');
        colorSwatch.type = 'color';
        colorSwatch.value = color;
        colorSwatch.className = 'lottie-color-swatch';
        colorSwatch.dataset.currentColor = color;

        const colorLabel = document.createElement('div');
        colorLabel.className = 'lottie-color-label';
        colorLabel.textContent = color.toUpperCase();

        colorSwatch.addEventListener('input', function(e) {
            const oldColor = colorSwatch.dataset.currentColor;
            const newColor = e.target.value;
            updateColor(oldColor, newColor);
            colorSwatch.dataset.currentColor = newColor;
            colorLabel.textContent = newColor.toUpperCase();
        });

        colorItem.appendChild(colorSwatch);
        colorItem.appendChild(colorLabel);
        colorContainer.appendChild(colorItem);
    }

    function updateColor(oldColor, newColor) {
        if (oldColor === newColor) return;

        const oldRgb = hexToRgbArray(oldColor);
        const newRgb = hexToRgbArray(newColor);

        if (!oldRgb || !newRgb) return;

        replaceColor(lottieData, oldRgb, newRgb);
        renderAnimation();
        markAsChanged();
    }

    function markAsChanged() {
        hasChanges = true;
        saveBtn.disabled = false;
    }

    function replaceColor(obj, oldRgb, newRgb) {
        if (typeof obj !== 'object' || obj === null) return;

        for (const key in obj) {
            const value = obj[key];

            // Handle color properties: c, s, fc
            if (['c', 's', 'fc'].includes(key) && Array.isArray(value)) {
                // Keyframed color (has 'k' property)
                if (value.k && Array.isArray(value.k) && value.k.length >= 3) {
                    if (colorsMatch(value.k, oldRgb)) {
                        value.k[0] = newRgb[0];
                        value.k[1] = newRgb[1];
                        value.k[2] = newRgb[2];
                    }
                }
                // Direct color array
                else if (value.length >= 3 && typeof value[0] === 'number') {
                    if (colorsMatch(value, oldRgb)) {
                        value[0] = newRgb[0];
                        value[1] = newRgb[1];
                        value[2] = newRgb[2];
                    }
                }
            }
            // Recurse into nested objects
            else if (typeof value === 'object') {
                replaceColor(value, oldRgb, newRgb);
            }
        }
    }

    function colorsMatch(color, targetRgb) {
        const tolerance = 0.01;
        return Math.abs(color[0] - targetRgb[0]) < tolerance &&
               Math.abs(color[1] - targetRgb[1]) < tolerance &&
               Math.abs(color[2] - targetRgb[2]) < tolerance;
    }

    // Save button handler
    saveBtn.addEventListener('click', function() {
        if (!hasChanges) return;

        saveBtn.disabled = true;
        saveBtn.textContent = '{{ "Saving..."|t('craft-lottie') }}';

        // Create a clean copy for saving (remove internal flags, apply layer visibility)
        const dataToSave = JSON.parse(JSON.stringify(lottieData));
        
        // Apply layer visibility changes to the saved data
        if (dataToSave.layers && Array.isArray(dataToSave.layers)) {
            dataToSave.layers.forEach((layer, index) => {
                const originalLayer = lottieData.layers[index];
                if (originalLayer && originalLayer._hidden === true) {
                    // Hide layer by setting op to ip
                    const layerIp = layer.ip !== undefined ? layer.ip : 0;
                    layer.op = layerIp;
                }
                // Remove internal flags
                delete layer._hidden;
                delete layer._originalOp;
            });
        }
        
        // Clean all internal flags from the entire structure
        cleanLottieData(dataToSave);

        const formData = new FormData();
        formData.append('assetId', assetId);
        formData.append('jsonData', JSON.stringify(dataToSave));
        formData.append('backgroundColor', backgroundColor || '');
        formData.append('speed', speedControl.value || '1.0');
        formData.append('{{ craft.app.request.csrfParam }}', '{{ craft.app.request.csrfToken }}');
        
        // Note: Text changes are already in lottieData from updateText() calls

        fetch('/actions/craft-lottie/default/save-asset-json', {
            method: 'POST',
            body: formData,
            headers: {
                'Accept': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`Server error: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                hasChanges = false;
                saveBtn.textContent = '{{ "Saved!"|t('craft-lottie') }}';
                setTimeout(() => {
                    saveBtn.textContent = '{{ "Save Changes"|t('craft-lottie') }}';
                    saveBtn.disabled = true;
                }, 2000);
                Craft.cp.displayNotice('{{ "Animation saved successfully"|t('craft-lottie') }}');
            } else {
                throw new Error(data.error || '{{ "Failed to save"|t('craft-lottie') }}');
            }
        })
        .catch(error => {
            console.error('Save failed:', error);
            saveBtn.disabled = false;
            saveBtn.textContent = '{{ "Save Changes"|t('craft-lottie') }}';
            Craft.cp.displayError('{{ "Failed to save animation:"|t('craft-lottie') }} ' + error.message);
        });
    });
}
{% endjs %}
