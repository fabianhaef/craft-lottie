{% extends "_layouts/cp" %}
{% import "_includes/forms" as forms %}

{% set title = "Edit: " ~ asset.filename %}

{% block content %}
    <div class="lottie-editor">
        <div class="lottie-editor-header">
            <div class="flex">
                <div class="flex-grow">
                    <h1>{{ asset.filename }}</h1>
                    <p class="light">{{ asset.volume.name }} • {{ asset.size|filesize }}</p>
                </div>
                <div class="flex gap">
                    <a href="{{ url('craft-lottie') }}" class="btn">{{ "← Back to Library"|t('craft-lottie') }}</a>
                    <button id="save-btn" class="btn submit" disabled>{{ "Save Changes"|t('craft-lottie') }}</button>
                    <button id="save-as-btn" class="btn">{{ "Save as Copy"|t('craft-lottie') }}</button>
                </div>
            </div>
        </div>

        <div class="lottie-editor-content">
            <div class="lottie-editor-grid">
                <!-- Preview Section -->
                <div class="lottie-preview-pane">
                    <div class="pane">
                        <h2>{{ "Preview"|t('craft-lottie') }}</h2>
                        <div id="lottie-preview" class="lottie-preview-container" data-asset-id="{{ asset.id }}">
                            <div class="lottie-loading">
                                <div class="spinner"></div>
                                <p>{{ "Loading animation..."|t('craft-lottie') }}</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Controls Section -->
                <div class="lottie-controls-pane">
                    <div class="pane">
                        <h2>{{ "Animation Settings"|t('craft-lottie') }}</h2>
                        
                        {% set speedLabel = "Playback Speed"|t('craft-lottie') %}
                        {% set speedInstructions = "Adjust the animation playback speed (0.1x to 5.0x)"|t('craft-lottie') %}
                        {{ forms.field({
                            label: speedLabel,
                            instructions: speedInstructions,
                            id: 'speed-field'
                        }, '<div class="lottie-speed-control-wrapper">
                            <input type="range" id="speed-control" min="0.1" max="5" step="0.1" value="1.0" class="lottie-speed-slider">
                            <div class="lottie-speed-display">
                                <input type="number" id="speed-input" min="0.1" max="5" step="0.1" value="1.0" class="lottie-speed-input">
                                <span class="lottie-speed-unit">x</span>
                            </div>
                        </div>') }}

                        {% set bgColorLabel = "Background Color"|t('craft-lottie') %}
                        {% set bgColorInstructions = "Set a background color for the animation preview"|t('craft-lottie') %}
                        {% set clearLabel = "Clear"|t('craft-lottie') %}
                        {{ forms.field({
                            label: bgColorLabel,
                            instructions: bgColorInstructions,
                            id: 'background-color-field'
                        }, '<div class="lottie-background-control-wrapper">
                            <input type="color" id="background-color" value="#ffffff" class="lottie-color-input">
                            <button type="button" id="clear-background" class="btn small">' ~ clearLabel ~ '</button>
                        </div>') }}

                        {% set colorsLabel = "Edit Colors"|t('craft-lottie') %}
                        {% set colorsInstructions = "Modify colors in the animation. Changes are applied in real-time."|t('craft-lottie') %}
                        {% set extractingColors = "Extracting colors..."|t('craft-lottie') %}
                        {{ forms.field({
                            label: colorsLabel,
                            instructions: colorsInstructions,
                            id: 'colors-field'
                        }, '<div id="color-picker-container" class="lottie-color-picker-container">
                            <div class="lottie-colors-loading">' ~ extractingColors ~ '</div>
                        </div>') }}

                        {% set textLabel = "Edit Text"|t('craft-lottie') %}
                        {% set textInstructions = "Modify text content in the animation. Changes are applied in real-time."|t('craft-lottie') %}
                        {% set extractingText = "Extracting text layers..."|t('craft-lottie') %}
                        {{ forms.field({
                            label: textLabel,
                            instructions: textInstructions,
                            id: 'text-editor-field'
                        }, '<div id="text-editor-container" class="lottie-text-editor-container">
                            <div class="lottie-text-loading">' ~ extractingText ~ '</div>
                        </div>') }}

                        {% set layersLabel = "Layer Management"|t('craft-lottie') %}
                        {% set layersInstructions = "Show or hide layers in the animation. Changes are applied in real-time."|t('craft-lottie') %}
                        {% set extractingLayers = "Extracting layers..."|t('craft-lottie') %}
                        {{ forms.field({
                            label: layersLabel,
                            instructions: layersInstructions,
                            id: 'layers-field'
                        }, '<div id="layers-container" class="lottie-layers-container">
                            <div class="lottie-layers-loading">' ~ extractingLayers ~ '</div>
                        </div>') }}

                        <hr>

                        {% set interactionsLabel = "Interactions"|t('craft-lottie') %}
                        {% set interactionsInstructions = "Configure interactive behaviors for the animation (scroll triggers, click actions, hover effects, URL links)."|t('craft-lottie') %}
                        {% set addInteractionLabel = "Add Interaction"|t('craft-lottie') %}
                        {% set scrollTriggerLabel = "Scroll Trigger"|t('craft-lottie') %}
                        {% set clickActionLabel = "Click Action"|t('craft-lottie') %}
                        {% set hoverEffectLabel = "Hover Effect"|t('craft-lottie') %}
                        {% set urlLinkLabel = "URL Link"|t('craft-lottie') %}
                        {{ forms.field({
                            label: interactionsLabel,
                            instructions: interactionsInstructions,
                            id: 'interactions-field'
                        }, '<div id="interactions-container" class="lottie-interactions-container">
                            <div class="btn menubtn" id="add-interaction-btn" data-icon="plus">' ~ addInteractionLabel ~ '</div>
                            <div class="menu" id="add-interaction-menu">
                                <ul class="padded">
                                    <li><a data-type="scroll" href="javascript:void(0)"><span class="icon" data-icon="arrows"></span> ' ~ scrollTriggerLabel ~ '</a></li>
                                    <li><a data-type="click" href="javascript:void(0)"><span class="icon" data-icon="pointer"></span> ' ~ clickActionLabel ~ '</a></li>
                                    <li><a data-type="hover" href="javascript:void(0)"><span class="icon" data-icon="cursor"></span> ' ~ hoverEffectLabel ~ '</a></li>
                                    <li><a data-type="url" href="javascript:void(0)"><span class="icon" data-icon="world"></span> ' ~ urlLinkLabel ~ '</a></li>
                                </ul>
                            </div>
                        </div>') }}
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% css %}
.lottie-editor-header {
    margin-bottom: 24px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--hairline-color);
}

.lottie-editor-header h1 {
    margin-bottom: 4px;
    font-size: 24px;
}

.lottie-editor-header .flex {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.lottie-editor-header .flex.gap {
    gap: 12px;
}

.lottie-editor-content {
    max-width: 1400px;
}

.lottie-editor-grid {
    display: grid;
    grid-template-columns: 1fr 400px;
    gap: 24px;
}

.lottie-preview-pane .pane,
.lottie-controls-pane .pane {
    padding: 24px;
    background: var(--pane-bg);
    border-radius: var(--pane-border-radius);
    box-shadow: var(--pane-shadow);
}

.lottie-preview-pane h2,
.lottie-controls-pane h2 {
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 16px;
    color: var(--text-color);
}

.lottie-preview-container {
    width: 100%;
    min-height: 400px;
    max-height: 600px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
}

.lottie-loading {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
    color: var(--light-text-color);
}

.lottie-loading .spinner {
    width: 32px;
    height: 32px;
    border: 3px solid var(--gray-200);
    border-top-color: var(--link-color);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.lottie-speed-control-wrapper {
    display: flex;
    align-items: center;
    gap: 16px;
}

.lottie-speed-slider {
    flex: 1;
    height: 6px;
    border-radius: 3px;
    background: var(--gray-200);
    outline: none;
    -webkit-appearance: none;
    cursor: pointer;
}

.lottie-speed-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--link-color);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s;
}

.lottie-speed-slider::-webkit-slider-thumb:hover {
    transform: scale(1.1);
}

.lottie-speed-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: var(--link-color);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    transition: transform 0.1s;
}

.lottie-speed-slider::-moz-range-thumb:hover {
    transform: scale(1.1);
}

.lottie-speed-display {
    display: flex;
    align-items: center;
    gap: 4px;
    min-width: 80px;
}

.lottie-speed-input {
    width: 60px;
    padding: 6px 8px;
    border: 1px solid var(--input-border-color);
    border-radius: var(--small-border-radius);
    background: var(--input-bg);
    font-size: 14px;
    text-align: center;
}

.lottie-speed-unit {
    font-size: 14px;
    color: var(--light-text-color);
    font-weight: 500;
}

.lottie-background-control-wrapper {
    display: flex;
    align-items: center;
    gap: 12px;
}

.lottie-color-input {
    width: 60px;
    height: 40px;
    border: 1px solid var(--input-border-color);
    border-radius: var(--small-border-radius);
    cursor: pointer;
    padding: 2px;
    background: var(--input-bg);
}

.lottie-color-picker-container {
    margin-top: 8px;
}

.lottie-palette-section {
    margin-bottom: 20px;
}

.lottie-palette-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--medium-text-color);
    margin-bottom: 8px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.lottie-palette-colors {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    margin-bottom: 12px;
}

.lottie-palette-swatch {
    width: 40px;
    height: 40px;
    border: 2px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    cursor: pointer;
    padding: 0;
    background: none;
    transition: all 0.2s;
    position: relative;
}

.lottie-palette-swatch:hover {
    border-color: var(--link-color);
    transform: scale(1.1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.lottie-palette-swatch:active {
    transform: scale(0.95);
}

.lottie-colors-separator {
    height: 1px;
    background: var(--hairline-color);
    margin: 16px 0;
}

.lottie-colors-extracted {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 12px;
}

.lottie-color-item {
    display: flex;
    flex-direction: column;
    gap: 8px;
    padding: 12px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    transition: all 0.2s;
}

.lottie-color-item:hover {
    border-color: var(--link-color);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.lottie-color-swatch {
    width: 100%;
    height: 40px;
    border-radius: var(--small-border-radius);
    border: 1px solid var(--hairline-color);
    cursor: pointer;
    padding: 2px;
    background: white;
}

.lottie-color-label {
    font-size: 12px;
    color: var(--light-text-color);
    text-align: center;
    word-break: break-all;
}

.lottie-colors-loading {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
}

.lottie-colors-empty {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
    font-style: italic;
}

.lottie-text-editor-container {
    display: flex;
    flex-direction: column;
    gap: 12px;
    margin-top: 8px;
}

.lottie-text-loading {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
}

.lottie-text-empty {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
    font-style: italic;
}

.lottie-text-item {
    padding: 12px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    transition: all 0.2s;
}

.lottie-text-item:hover {
    border-color: var(--link-color);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.lottie-text-header {
    font-size: 13px;
    font-weight: 600;
    color: var(--text-color);
    margin-bottom: 8px;
    padding-bottom: 6px;
    border-bottom: 1px solid var(--hairline-color);
}

.lottie-text-input-wrapper {
    margin-top: 8px;
}

.lottie-text-input-wrapper:first-of-type {
    margin-top: 0;
}

.lottie-text-label {
    display: block;
    font-size: 12px;
    color: var(--light-text-color);
    margin-bottom: 4px;
}

.lottie-text-input {
    width: 100%;
    padding: 6px 8px;
    border: 1px solid var(--input-border-color);
    border-radius: var(--small-border-radius);
    background: var(--input-bg);
    font-size: 14px;
    transition: border-color 0.2s;
}

.lottie-text-input:focus {
    outline: none;
    border-color: var(--link-color);
    box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
}

.lottie-layers-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
    margin-top: 8px;
    max-height: 400px;
    overflow-y: auto;
}

.lottie-layers-loading {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
}

.lottie-layers-empty {
    padding: 20px;
    text-align: center;
    color: var(--light-text-color);
    font-size: 14px;
    font-style: italic;
}

.lottie-layer-item {
    padding: 10px 12px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    transition: all 0.2s;
}

.lottie-layer-item:hover {
    border-color: var(--link-color);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.lottie-layer-toggle {
    display: flex;
    align-items: center;
    cursor: pointer;
    user-select: none;
}

.lottie-layer-toggle-label {
    display: flex;
    align-items: center;
    gap: 10px;
    width: 100%;
}

.lottie-layer-checkbox {
    width: 18px;
    height: 18px;
    cursor: pointer;
    flex-shrink: 0;
}

.lottie-layer-info {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.lottie-layer-name {
    font-size: 13px;
    font-weight: 500;
    color: var(--text-color);
}

.lottie-layer-type {
    font-size: 11px;
    color: var(--light-text-color);
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.lottie-layer-item:has(.lottie-layer-checkbox:not(:checked)) {
    opacity: 0.6;
}

.lottie-layer-item:has(.lottie-layer-checkbox:not(:checked)) .lottie-layer-name {
    text-decoration: line-through;
}

.lottie-error {
    padding: 24px;
    text-align: center;
    background: #fef2f2;
    border: 1px solid #fecaca;
    border-radius: var(--small-border-radius);
}

.lottie-error > div:first-child {
    color: #cf1124;
    font-size: 18px;
    font-weight: 600;
    margin-bottom: 8px;
}

.lottie-error > div:nth-child(2) {
    color: #6b7280;
    font-size: 14px;
    margin-bottom: 16px;
}

.lottie-error > div:last-child {
    font-size: 12px;
    color: #9ca3af;
}

.lottie-interactions-container {
    margin-top: 8px;
    position: relative;
}

#add-interaction-btn {
    margin-bottom: 12px;
}

.lottie-interaction-item {
    padding: 12px;
    background: var(--gray-050);
    border: 1px solid var(--hairline-color);
    border-radius: var(--small-border-radius);
    margin-bottom: 12px;
    transition: all 0.2s;
}

.lottie-interaction-item:hover {
    border-color: var(--link-color);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.lottie-interaction-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 12px;
}

.lottie-interaction-title {
    font-size: 14px;
    font-weight: 600;
    color: var(--text-color);
}

.lottie-interaction-remove {
    flex-shrink: 0;
}

.lottie-interaction-fields {
    display: grid;
    gap: 12px;
}

.lottie-interaction-field {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.lottie-interaction-field label {
    font-size: 12px;
    color: var(--light-text-color);
    font-weight: 500;
}

.lottie-interaction-field select,
.lottie-interaction-field input {
    padding: 6px 8px;
    border: 1px solid var(--input-border-color);
    border-radius: var(--small-border-radius);
    background: var(--input-bg);
    font-size: 14px;
}

.lottie-interaction-field input[type="checkbox"] {
    width: auto;
    margin-right: 8px;
}

.lottie-interaction-field-row {
    display: flex;
    align-items: center;
    gap: 8px;
}

@media (max-width: 1200px) {
    .lottie-editor-grid {
        grid-template-columns: 1fr;
    }
    
    .lottie-controls-pane {
        order: -1;
    }
}
{% endcss %}

{% js %}
// Load lottie-web library dynamically
// Using version 5.9.6 which is more stable with minimal text layer structures
const lottieScript = document.createElement('script');
lottieScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.9.6/lottie.min.js';
lottieScript.onload = function() {
    initLottieEditor();
};
lottieScript.onerror = function() {
    const previewContainer = document.getElementById('lottie-preview');
    if (previewContainer) {
        previewContainer.innerHTML = '<div class="lottie-loading"><p style="color: #cf1124;">Failed to load Lottie library. Please refresh the page.</p></div>';
    }
};
document.head.appendChild(lottieScript);

function initLottieEditor() {
    const previewContainer = document.getElementById('lottie-preview');
    const speedControl = document.getElementById('speed-control');
    const speedInput = document.getElementById('speed-input');
    const colorContainer = document.getElementById('color-picker-container');
    const backgroundColorInput = document.getElementById('background-color');
    const clearBackgroundBtn = document.getElementById('clear-background');

    // Get brand palette from template
    const brandPalette = {{ brandPalette|default([])|json_encode|raw }};
    
    // Define interaction type labels as JavaScript constants
    const scrollTriggerLabel = '{{ "Scroll Trigger"|t('craft-lottie')|e('js') }}';
    const clickActionLabel = '{{ "Click Action"|t('craft-lottie')|e('js') }}';
    const hoverEffectLabel = '{{ "Hover Effect"|t('craft-lottie')|e('js') }}';
    const urlLinkLabel = '{{ "URL Link"|t('craft-lottie')|e('js') }}';

    // Get asset ID from data attribute
    const assetId = previewContainer.getAttribute('data-asset-id');

    if (!assetId) {
        previewContainer.innerHTML = '<div class="lottie-loading"><p style="color: #cf1124;">Invalid asset ID</p></div>';
        return;
    }

    let lottieAnimation = null;
    let lottieData = null;
    let hasChanges = false;
    let backgroundColor = null;
    let interactions = [];

    const saveBtn = document.getElementById('save-btn');
    const saveAsBtn = document.getElementById('save-as-btn');

    // Load the Lottie file via controller action
    const fetchUrl = '/actions/craft-lottie/default/get-asset-json?assetId=' + assetId;

    fetch(fetchUrl)
        .then(response => {
            if (!response.ok) {
                // Try to get error details from response
                return response.json().then(data => {
                    throw new Error(data.error || 'HTTP ' + response.status + ': ' + response.statusText);
                }).catch(() => {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                });
            }
            return response.json();
        })
        .then(data => {
            
            if (data.error) {
                const errorCode = data.errorCode || 'UNKNOWN_ERROR';
                const errorMessage = data.error || 'An unknown error occurred';
                console.error('Lottie load error:', errorCode, errorMessage);
                showError(errorMessage, errorCode);
                return;
            }
            
            lottieData = data.animation || data;
            backgroundColor = data.backgroundColor || null;
            const savedSpeed = data.speed || 1.0;
            interactions = data.interactions || [];

            if (backgroundColor) {
                backgroundColorInput.value = backgroundColor;
            }
            
            if (speedControl && speedInput) {
                speedControl.value = savedSpeed;
                speedInput.value = savedSpeed;
            }

            // Validate data structure before proceeding
            if (!lottieData || typeof lottieData !== 'object') {
                showError('Invalid animation data structure', 'INVALID_DATA');
                return;
            }
            
            renderAnimation();
            extractColors();
            extractTextLayers();
            extractLayers();
            renderInteractions();
        })
        .catch(error => {
            console.error('Failed to load Lottie file:', error);
            // Try to get error details from response if available
            if (error.response) {
                error.response.json().then(data => {
                    if (data.error) {
                        showError(data.error, data.errorCode || 'NETWORK_ERROR');
                    } else {
                        showError(error.message || 'An unexpected error occurred while loading the animation.', 'NETWORK_ERROR');
                    }
                }).catch(() => {
                    showError(error.message || 'An unexpected error occurred while loading the animation.', 'NETWORK_ERROR');
                });
            } else {
                showError(error.message || 'An unexpected error occurred while loading the animation.', 'NETWORK_ERROR');
            }
        });

    function showError(message, errorCode = 'ERROR') {
        const errorHtml = `
            <div class="lottie-error" style="padding: 24px; text-align: center;">
                <div style="color: #cf1124; font-size: 18px; font-weight: 600; margin-bottom: 8px;">
                    Unable to load animation
                </div>
                <div style="color: #6b7280; font-size: 14px; margin-bottom: 16px;">
                    ${escapeHtml(message)}
                </div>
                <div style="font-size: 12px; color: #9ca3af;">
                    Error code: ${errorCode}
                </div>
            </div>
        `;
        previewContainer.innerHTML = errorHtml;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function renderAnimation() {
        if (lottieAnimation) {
            try {
                lottieAnimation.destroy();
            } catch (e) {
                // Ignore destroy errors
            }
            lottieAnimation = null;
        }

        // Clear loading state
        previewContainer.innerHTML = '';

        // Apply background color
        if (backgroundColor) {
            previewContainer.style.backgroundColor = backgroundColor;
        } else {
            previewContainer.style.backgroundColor = '';
        }

        if (!lottieData) {
            previewContainer.innerHTML = '<div class="lottie-loading"><p style="color: #cf1124;">No animation data available</p></div>';
            return;
        }

        try {
            // Create a clean copy without our internal flags
            const animationDataCopy = JSON.parse(JSON.stringify(lottieData));
            
            // Remove our internal flags before rendering
            cleanLottieData(animationDataCopy);
            
            
            // Text layers need t.p, t.m, and t.a to work properly with lottie-web
            if (animationDataCopy.layers && Array.isArray(animationDataCopy.layers)) {
                animationDataCopy.layers.forEach((layer, idx) => {
                    if (layer.ty === 5 && layer.t) {
                        
                        if (!layer.t.p) {
                            layer.t.p = {};
                        }
                        
                        // Add text more options if missing
                        if (!layer.t.m) {
                            layer.t.m = {
                                g: 1,
                                a: { a: 0, k: [0, 0], ix: 2 }
                            };
                        }
                        
                        // Add empty text animators array if missing
                        if (!layer.t.a) {
                            layer.t.a = [];
                        }
                    }
                });
            }
            
            // Re-enable keyframe structure fixes
            fixKeyframeStructures(animationDataCopy);
            
            // Apply layer visibility by filtering layers (safer than modifying op)
            if (animationDataCopy.layers && Array.isArray(animationDataCopy.layers) && lottieData.layers) {
                // Filter out hidden layers for preview
                animationDataCopy.layers = animationDataCopy.layers.filter((layer, index) => {
                    const originalLayer = lottieData.layers[index];
                    if (originalLayer && originalLayer._hidden === true) {
                        return false; // Hide this layer
                    }
                    return true; // Show this layer
                });
            }
                        (animationDataCopy.layers||[]).forEach((layer, idx) => {
                const layerInfo = {
                    idx,
                    nm: layer.nm,
                    ty: layer.ty,
                    hasKs: !!layer.ks,
                    ksKeys: layer.ks ? Object.keys(layer.ks) : [],
                    // Check each transform property for issues
                    ks_o: layer.ks?.o ? {a: layer.ks.o.a, hasK: layer.ks.o.k !== undefined} : 'MISSING',
                    ks_r: layer.ks?.r ? {a: layer.ks.r.a, hasK: layer.ks.r.k !== undefined} : 'MISSING',
                    ks_p: layer.ks?.p ? {a: layer.ks.p.a, hasK: layer.ks.p.k !== undefined} : 'MISSING',
                    ks_a: layer.ks?.a ? {a: layer.ks.a.a, hasK: layer.ks.a.k !== undefined} : 'MISSING',
                    ks_s: layer.ks?.s ? {a: layer.ks.s.a, hasK: layer.ks.s.k !== undefined} : 'MISSING',
                    // Check for parent reference
                    parent: layer.parent,
                    // For text layers, check t structure
                    hasT: layer.ty === 5 ? !!layer.t : 'N/A',
                    t_keys: layer.ty === 5 && layer.t ? Object.keys(layer.t) : 'N/A'
                };
            });
            
            
            lottieAnimation = lottie.loadAnimation({
                container: previewContainer,
                renderer: 'svg',
                loop: true,
                autoplay: true,
                animationData: animationDataCopy
            });

            // Apply speed
            const speed = parseFloat(speedControl.value) || 1.0;
            if (!isNaN(speed) && speed > 0) {
                lottieAnimation.setSpeed(speed);
            } else {
                lottieAnimation.setSpeed(1.0);
            }
        } catch (error) {
            console.error('Error rendering animation:', error);
            console.error('Error details:', {
                message: error.message,
                stack: error.stack,
                name: error.name
            });
            console.error('Lottie data keys:', lottieData ? Object.keys(lottieData) : 'null');
            showError('Error rendering animation: ' + error.message, 'RENDER_ERROR');
        }
    }

    function fixKeyframeStructures(obj, path = '') {
        // Recursively fix keyframe structures that might be missing 'a' property
        if (Array.isArray(obj)) {
            obj.forEach((item, idx) => fixKeyframeStructures(item, `${path}[${idx}]`));
        } else if (obj && typeof obj === 'object' && obj !== null) {
            // Check if this looks like an animated property (has 'k' but missing 'a')
            // BUT skip text document data (t.d) which has 'k' as keyframe array, not animated value
            if (obj.k !== undefined && obj.a === undefined) {
                // Skip if this looks like text document data (t.d)
                // Text document 'k' is an array of keyframes with 's' (style) and 't' (time) properties
                const isTextDocumentData = Array.isArray(obj.k) && obj.k.length > 0 && 
                    obj.k[0] && typeof obj.k[0] === 'object' && 
                    (obj.k[0].s !== undefined || obj.k[0].t !== undefined);
                
                if (!isTextDocumentData) {
                    obj.a = 0;
                }
            }
            
            // Check common keyframe properties in transforms (ks object)
            if (obj.ks && typeof obj.ks === 'object') {
                const keyframeProps = ['o', 'r', 'p', 'a', 's', 't', 'sk', 'sa', 'sc', 'sw', 'rx', 'ry', 'rz', 'or'];
                for (const prop of keyframeProps) {
                    if (obj.ks[prop] && typeof obj.ks[prop] === 'object') {
                        if (obj.ks[prop].k !== undefined && obj.ks[prop].a === undefined) {
                            obj.ks[prop].a = 0;
                        }
                        // Fix nested keyframe arrays
                        if (Array.isArray(obj.ks[prop].k)) {
                            obj.ks[prop].k.forEach((kf, idx) => {
                                if (kf && typeof kf === 'object' && kf.s !== undefined && kf.s !== null) {
                                    // Keyframe has a value, ensure it's valid
                                    if (typeof kf.s === 'object' && kf.s.a === undefined && kf.s.k !== undefined) {
                                        kf.s.a = 0;
                                    }
                                }
                            });
                        }
                    }
                }
            }
            
            // Fix shape properties
            if (Array.isArray(obj.shapes)) {
                obj.shapes.forEach((shape, idx) => {
                    if (shape && typeof shape === 'object') {
                        // Fix shape transform properties
                        if (shape.p && typeof shape.p === 'object' && shape.p.k !== undefined && shape.p.a === undefined) {
                            shape.p.a = 0;
                        }
                        if (shape.s && typeof shape.s === 'object' && shape.s.k !== undefined && shape.s.a === undefined) {
                            shape.s.a = 0;
                        }
                        // Fix color properties
                        if (shape.c && typeof shape.c === 'object' && shape.c.k !== undefined && shape.c.a === undefined) {
                            shape.c.a = 0;
                        }
                        if (shape.o && typeof shape.o === 'object' && shape.o.k !== undefined && shape.o.a === undefined) {
                            shape.o.a = 0;
                        }
                    }
                });
            }
            
            // Recursively process nested objects
            for (const key in obj) {
                if (obj.hasOwnProperty(key) && typeof obj[key] === 'object' && obj[key] !== null) {
                    fixKeyframeStructures(obj[key], path ? `${path}.${key}` : key);
                }
            }
        }
    }

    function cleanLottieData(obj) {
        // Recursively remove our internal flags (_hidden, _originalOp)
        if (Array.isArray(obj)) {
            obj.forEach(item => cleanLottieData(item));
        } else if (obj && typeof obj === 'object') {
            // Remove internal flags but keep the structure
            delete obj._hidden;
            // Keep _originalOp for now as we need it for restoration
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    cleanLottieData(obj[key]);
                }
            }
        }
    }


    // Speed control synchronization
    function syncSpeed(value) {
        if (speedControl) speedControl.value = value;
        if (speedInput) speedInput.value = value;
        if (lottieAnimation) {
            const speed = parseFloat(value) || 1.0;
            lottieAnimation.setSpeed(speed);
        }
        markAsChanged();
    }

    speedControl.addEventListener('input', function() {
        syncSpeed(this.value);
    });

    speedInput.addEventListener('input', function() {
        let value = parseFloat(this.value);
        if (isNaN(value) || value < 0.1) value = 0.1;
        if (value > 5.0) value = 5.0;
        this.value = value;
        syncSpeed(value);
    });

    speedInput.addEventListener('blur', function() {
        if (!this.value || parseFloat(this.value) <= 0) {
            this.value = 1.0;
            syncSpeed(1.0);
        }
    });

    // Background color control
    backgroundColorInput.addEventListener('input', function(e) {
        backgroundColor = e.target.value;
        if (previewContainer) {
            previewContainer.style.backgroundColor = backgroundColor;
        }
        markAsChanged();
    });

    clearBackgroundBtn.addEventListener('click', function() {
        backgroundColor = null;
        backgroundColorInput.value = '#ffffff';
        if (previewContainer) {
            previewContainer.style.backgroundColor = '';
        }
        markAsChanged();
    });

    // Extract text layers from Lottie JSON
    function extractTextLayers() {
        const textContainer = document.getElementById('text-editor-container');
        if (!textContainer) return;

        const textLayers = [];
        findTextLayers(lottieData, textLayers);

        textContainer.innerHTML = '';

        if (textLayers.length === 0) {
            textContainer.innerHTML = '<div class="lottie-text-empty">{{ "No editable text layers found in this animation"|t('craft-lottie') }}</div>';
            return;
        }

        textLayers.forEach((textLayer, index) => {
            createTextEditor(textLayer, index);
        });
    }

    function findTextLayers(obj, textLayers, layerPath = '', layerIndex = 0) {
        if (typeof obj !== 'object' || obj === null) return;

        // Recursively search in layers array first (most common structure)
        if (Array.isArray(obj.layers)) {
            obj.layers.forEach((layer, index) => {
                const currentPath = layerPath ? `${layerPath}.layers[${index}]` : `layers[${index}]`;
                findTextLayers(layer, textLayers, currentPath, index);
            });
            return; // Don't process layers array itself as a text layer
        }

        // Check if this is a layer with text (ty === 5 means text layer)
        if (obj.ty === 5 && obj.t) {
            const textData = obj.t;
            let texts = [];

            // Handle different text data structures
            // Structure: t.d.k[].s.t (keyframed) or t.d.k.s.t (static)
            if (textData.d && textData.d.k) {
                if (Array.isArray(textData.d.k)) {
                    // Keyframed text: k is an array of keyframes
                    textData.d.k.forEach((keyframe, kIndex) => {
                        if (keyframe.s && typeof keyframe.s.t === 'string') {
                            texts.push({
                                text: keyframe.s.t,
                                keyframeIndex: kIndex,
                                isKeyframed: true,
                                keyframeData: keyframe
                            });
                        }
                    });
                } else if (textData.d.k.s && typeof textData.d.k.s.t === 'string') {
                    // Single keyframe or static text
                    texts.push({
                        text: textData.d.k.s.t,
                        keyframeIndex: 0,
                        isKeyframed: Array.isArray(textData.d.k) === false,
                        keyframeData: textData.d.k
                    });
                }
            }

            if (texts.length > 0) {
                textLayers.push({
                    layerIndex: layerIndex,
                    layerName: obj.nm || `Text Layer ${textLayers.length + 1}`,
                    layerPath: layerPath,
                    texts: texts,
                    layerData: obj
                });
            }
        }
    }

    function createTextEditor(textLayer, index) {
        const textItem = document.createElement('div');
        textItem.className = 'lottie-text-item';
        textItem.dataset.layerIndex = textLayer.layerIndex;
        textItem.dataset.layerPath = textLayer.layerPath;

        const textHeader = document.createElement('div');
        textHeader.className = 'lottie-text-header';
        textHeader.textContent = textLayer.layerName;

        textItem.appendChild(textHeader);

        // Create input for each text in the layer
        textLayer.texts.forEach((textObj, textIndex) => {
            const textInputWrapper = document.createElement('div');
            textInputWrapper.className = 'lottie-text-input-wrapper';

            const textLabel = document.createElement('label');
            textLabel.className = 'lottie-text-label';
            if (textLayer.texts.length > 1) {
                textLabel.textContent = `{{ "Text"|t('craft-lottie') }} ${textIndex + 1}${textObj.isKeyframed ? ' ({{ "Keyframe"|t('craft-lottie') }} ' + (textObj.keyframeIndex + 1) + ')' : ''}`;
            } else {
                textLabel.textContent = '{{ "Text Content"|t('craft-lottie') }}';
            }

            const textInput = document.createElement('input');
            textInput.type = 'text';
            textInput.className = 'lottie-text-input';
            textInput.value = textObj.text;
            textInput.dataset.textIndex = textIndex;
            textInput.dataset.keyframeIndex = textObj.keyframeIndex;
            textInput.dataset.isKeyframed = textObj.isKeyframed;

            textInput.addEventListener('input', function() {
                updateText(textLayer, textIndex, this.value);
            });

            textInputWrapper.appendChild(textLabel);
            textInputWrapper.appendChild(textInput);
            textItem.appendChild(textInputWrapper);
        });

        document.getElementById('text-editor-container').appendChild(textItem);
    }

    function updateText(textLayer, textIndex, newText) {
        const layer = getLayerByPath(lottieData, textLayer.layerPath);
        if (!layer || !layer.t || !layer.t.d) {
            console.warn('Could not find layer at path:', textLayer.layerPath);
            return;
        }

        const textObj = textLayer.texts[textIndex];
        
        // Update the text in the JSON structure
        if (Array.isArray(layer.t.d.k)) {
            // Keyframed text: update specific keyframe
            const keyframe = layer.t.d.k[textObj.keyframeIndex];
            if (keyframe && keyframe.s) {
                keyframe.s.t = newText;
            }
        } else if (layer.t.d.k && layer.t.d.k.s) {
            // Static text or single keyframe
            layer.t.d.k.s.t = newText;
        }

        // Update the text in our textLayer object for UI consistency
        textObj.text = newText;

        renderAnimation();
        markAsChanged();
    }

    function getLayerByPath(obj, path) {
        if (!path) return obj;
        
        // Handle paths like "layers[0]" or "layers[0].layers[1]"
        const parts = path.split('.');
        let current = obj;
        
        for (const part of parts) {
            const arrayMatch = part.match(/^(\w+)\[(\d+)\]$/);
            if (arrayMatch) {
                const [, key, index] = arrayMatch;
                if (current && current[key] && Array.isArray(current[key])) {
                    const idx = parseInt(index);
                    if (idx >= 0 && idx < current[key].length) {
                        current = current[key][idx];
                    } else {
                        console.warn(`Index ${idx} out of bounds for ${key}`);
                        return null;
                    }
                } else {
                    console.warn(`Could not access ${key}[${index}]`);
                    return null;
                }
            } else {
                if (current && current[part]) {
                    current = current[part];
                } else {
                    console.warn(`Could not access property ${part}`);
                    return null;
                }
            }
        }
        
        return current;
    }

    // Extract and manage layers
    function extractLayers() {
        const layersContainer = document.getElementById('layers-container');
        if (!layersContainer) return;

        if (!lottieData || !lottieData.layers || !Array.isArray(lottieData.layers)) {
            layersContainer.innerHTML = '<div class="lottie-layers-empty">{{ "No layers found in this animation"|t('craft-lottie') }}</div>';
            return;
        }

        layersContainer.innerHTML = '';

        // Process layers in reverse order (top to bottom in UI, but maintain layer order)
        const layers = [...lottieData.layers].reverse();
        
        layers.forEach((layer, index) => {
            const originalIndex = lottieData.layers.length - 1 - index;
            createLayerControl(layer, originalIndex);
        });
    }

    function createLayerControl(layer, layerIndex) {
        const layerItem = document.createElement('div');
        layerItem.className = 'lottie-layer-item';
        layerItem.dataset.layerIndex = layerIndex;

        // Determine if layer is visible
        // Check _hidden flag first, then check op > ip
        const layerIp = layer.ip !== undefined ? layer.ip : 0;
        const layerOp = layer.op !== undefined ? layer.op : (lottieData.op || 60);
        const isVisible = layer._hidden === undefined ? (layerOp > layerIp) : !layer._hidden;

        const layerToggle = document.createElement('label');
        layerToggle.className = 'lottie-layer-toggle';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = isVisible;
        checkbox.className = 'lottie-layer-checkbox';
        
        const toggleLabel = document.createElement('span');
        toggleLabel.className = 'lottie-layer-toggle-label';
        
        const layerInfo = document.createElement('div');
        layerInfo.className = 'lottie-layer-info';
        
        const layerName = document.createElement('div');
        layerName.className = 'lottie-layer-name';
        layerName.textContent = layer.nm || `Layer ${layerIndex + 1}`;
        
        const layerType = document.createElement('div');
        layerType.className = 'lottie-layer-type';
        layerType.textContent = getLayerTypeName(layer.ty);

        layerInfo.appendChild(layerName);
        layerInfo.appendChild(layerType);

        toggleLabel.appendChild(checkbox);
        toggleLabel.appendChild(layerInfo);
        layerToggle.appendChild(toggleLabel);

        checkbox.addEventListener('change', function() {
            toggleLayerVisibility(layerIndex, this.checked);
        });

        layerItem.appendChild(layerToggle);
        document.getElementById('layers-container').appendChild(layerItem);
    }

    function getLayerTypeName(type) {
        const types = {
            0: 'Precomp',
            1: 'Solid',
            2: 'Image',
            3: 'Null',
            4: 'Shape',
            5: 'Text',
            6: 'Audio',
            13: 'Camera'
        };
        return types[type] || `Type ${type}`;
    }

    function toggleLayerVisibility(layerIndex, visible) {
        if (!lottieData.layers || !lottieData.layers[layerIndex]) {
            console.warn('Layer not found at index:', layerIndex);
            return;
        }

        const layer = lottieData.layers[layerIndex];
        const animationOp = lottieData.op || 60;
        const layerIp = layer.ip !== undefined ? layer.ip : 0;
        
        // Store original op if not already stored
        if (!layer._originalOp) {
            layer._originalOp = layer.op !== undefined ? layer.op : animationOp;
        }

        // Store visibility state
        layer._hidden = !visible;

        // Re-render with updated visibility
        renderAnimation();
        markAsChanged();
    }

    // Extract colors from Lottie JSON
    function extractColors() {
        const colors = new Set();
        findColors(lottieData, colors);

        colorContainer.innerHTML = '';

        // Show brand palette first if available
        if (brandPalette && brandPalette.length > 0) {
            const paletteSection = document.createElement('div');
            paletteSection.className = 'lottie-palette-section';
            
            const paletteTitle = document.createElement('div');
            paletteTitle.className = 'lottie-palette-title';
            paletteTitle.textContent = '{{ "Brand Palette"|t('craft-lottie') }}';
            paletteSection.appendChild(paletteTitle);
            
            const paletteColors = document.createElement('div');
            paletteColors.className = 'lottie-palette-colors';
            
            brandPalette.forEach((paletteColor) => {
                createPaletteColorSwatch(paletteColor, paletteColors);
            });
            
            paletteSection.appendChild(paletteColors);
            colorContainer.appendChild(paletteSection);
            
            // Add separator if there are extracted colors
            if (colors.size > 0) {
                const separator = document.createElement('div');
                separator.className = 'lottie-colors-separator';
                colorContainer.appendChild(separator);
            }
        }

        if (colors.size === 0 && (!brandPalette || brandPalette.length === 0)) {
            colorContainer.innerHTML = '<div class="lottie-colors-empty">{{ "No editable colors found in this animation"|t('craft-lottie') }}</div>';
            return;
        }

        // Show extracted colors from animation
        if (colors.size > 0) {
            const extractedSection = document.createElement('div');
            extractedSection.className = 'lottie-colors-extracted';
            
            const extractedTitle = document.createElement('div');
            extractedTitle.className = 'lottie-palette-title';
            extractedTitle.textContent = '{{ "Animation Colors"|t('craft-lottie') }}';
            extractedTitle.style.gridColumn = '1 / -1';
            extractedSection.appendChild(extractedTitle);
            
            Array.from(colors).forEach((color, index) => {
                createColorPicker(color, index, extractedSection);
            });
            
            colorContainer.appendChild(extractedSection);
        }
    }
    
    function createPaletteColorSwatch(color, container) {
        const swatch = document.createElement('button');
        swatch.type = 'button';
        swatch.className = 'lottie-palette-swatch';
        swatch.style.backgroundColor = color;
        swatch.title = color.toUpperCase();
        swatch.dataset.color = color;
        
        swatch.addEventListener('click', function() {
            // Apply this palette color to all matching colors in the animation
            const extractedColors = new Set();
            findColors(lottieData, extractedColors);
            
            // Find the closest matching color in the animation
            let closestColor = null;
            let minDistance = Infinity;
            
            extractedColors.forEach(extractedColor => {
                const distance = colorDistance(color, extractedColor);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = extractedColor;
                }
            });
            
            if (closestColor) {
                updateColor(closestColor, color);
                // Re-extract colors to update UI
                extractColors();
            } else {
                Craft.cp.displayNotice('{{ "No colors found in animation to replace"|t('craft-lottie') }}');
            }
        });
        
        container.appendChild(swatch);
    }
    
    function colorDistance(color1, color2) {
        const rgb1 = hexToRgbArray(color1);
        const rgb2 = hexToRgbArray(color2);
        if (!rgb1 || !rgb2) return Infinity;
        
        const r = rgb1[0] - rgb2[0];
        const g = rgb1[1] - rgb2[1];
        const b = rgb1[2] - rgb2[2];
        return Math.sqrt(r * r + g * g + b * b);
    }

    function findColors(obj, colors, path = '') {
        if (typeof obj !== 'object' || obj === null) return;

        for (const key in obj) {
            const value = obj[key];

            // Look for color arrays: 'c', 's' (stroke), 'fc' (fill color)
            if (['c', 's', 'fc'].includes(key) && Array.isArray(value)) {
                // Check if it's a keyframed color (has 'k' property)
                if (value.k && Array.isArray(value.k) && value.k.length >= 3) {
                    const colorHex = rgbArrayToHex(value.k);
                    colors.add(colorHex);
                }
                // Check if it's a direct color array
                else if (value.length >= 3 && typeof value[0] === 'number') {
                    const colorHex = rgbArrayToHex(value);
                    colors.add(colorHex);
                }
            }
            // Recursively search nested objects
            else if (typeof value === 'object') {
                findColors(value, colors, path ? `${path}.${key}` : key);
            }
        }
    }

    function rgbArrayToHex(rgbArray) {
        const r = Math.round(rgbArray[0] * 255);
        const g = Math.round(rgbArray[1] * 255);
        const b = Math.round(rgbArray[2] * 255);
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
    }

    function hexToRgbArray(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? [
            parseInt(result[1], 16) / 255,
            parseInt(result[2], 16) / 255,
            parseInt(result[3], 16) / 255
        ] : null;
    }

    function createColorPicker(color, index, container) {
        const colorItem = document.createElement('div');
        colorItem.className = 'lottie-color-item';

        const colorSwatch = document.createElement('input');
        colorSwatch.type = 'color';
        colorSwatch.value = color;
        colorSwatch.className = 'lottie-color-swatch';
        colorSwatch.dataset.currentColor = color;

        const colorLabel = document.createElement('div');
        colorLabel.className = 'lottie-color-label';
        colorLabel.textContent = color.toUpperCase();

        colorSwatch.addEventListener('input', function(e) {
            const oldColor = colorSwatch.dataset.currentColor;
            const newColor = e.target.value;
            updateColor(oldColor, newColor);
            colorSwatch.dataset.currentColor = newColor;
            colorLabel.textContent = newColor.toUpperCase();
        });

        colorItem.appendChild(colorSwatch);
        colorItem.appendChild(colorLabel);
        (container || colorContainer).appendChild(colorItem);
    }

    function updateColor(oldColor, newColor) {
        if (oldColor === newColor) return;

        const oldRgb = hexToRgbArray(oldColor);
        const newRgb = hexToRgbArray(newColor);

        if (!oldRgb || !newRgb) return;

        replaceColor(lottieData, oldRgb, newRgb);
        renderAnimation();
        markAsChanged();
    }

    function markAsChanged() {
        hasChanges = true;
        saveBtn.disabled = false;
    }

    function replaceColor(obj, oldRgb, newRgb) {
        if (typeof obj !== 'object' || obj === null) return;

        for (const key in obj) {
            const value = obj[key];

            // Handle color properties: c, s, fc
            if (['c', 's', 'fc'].includes(key) && Array.isArray(value)) {
                // Keyframed color (has 'k' property)
                if (value.k && Array.isArray(value.k) && value.k.length >= 3) {
                    if (colorsMatch(value.k, oldRgb)) {
                        value.k[0] = newRgb[0];
                        value.k[1] = newRgb[1];
                        value.k[2] = newRgb[2];
                    }
                }
                // Direct color array
                else if (value.length >= 3 && typeof value[0] === 'number') {
                    if (colorsMatch(value, oldRgb)) {
                        value[0] = newRgb[0];
                        value[1] = newRgb[1];
                        value[2] = newRgb[2];
                    }
                }
            }
            // Recurse into nested objects
            else if (typeof value === 'object') {
                replaceColor(value, oldRgb, newRgb);
            }
        }
    }

    function colorsMatch(color, targetRgb) {
        const tolerance = 0.01;
        return Math.abs(color[0] - targetRgb[0]) < tolerance &&
               Math.abs(color[1] - targetRgb[1]) < tolerance &&
               Math.abs(color[2] - targetRgb[2]) < tolerance;
    }

    // Interactions management
    const interactionsContainer = document.getElementById('interactions-container');

    function renderInteractions() {
        if (!interactionsContainer) return;
        
        // Ensure interactions is initialized
        if (!interactions) {
            interactions = [];
        }
        
        // Clear existing interactions (except add button and menu)
        const existingItems = interactionsContainer.querySelectorAll('.lottie-interaction-item');
        existingItems.forEach(item => item.remove());
        
        if (interactions.length === 0) {
            return;
        }
        
        interactions.forEach((interaction, index) => {
            createInteractionItem(interaction, index);
        });
    }

    function createInteractionItem(interaction, index) {
        const item = document.createElement('div');
        item.className = 'lottie-interaction-item';
        item.dataset.index = index;
        
        const header = document.createElement('div');
        header.className = 'lottie-interaction-header';
        
        const title = document.createElement('div');
        title.className = 'lottie-interaction-title';
        title.textContent = getInteractionTypeLabel(interaction.type);
        
        const removeBtn = document.createElement('button');
        removeBtn.type = 'button';
        removeBtn.className = 'btn small lottie-interaction-remove';
        removeBtn.textContent = '{{ "Remove"|t('craft-lottie') }}';
        removeBtn.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            interactions.splice(index, 1);
            renderInteractions();
            markAsChanged();
        });
        
        header.appendChild(title);
        header.appendChild(removeBtn);
        item.appendChild(header);
        
        const fields = document.createElement('div');
        fields.className = 'lottie-interaction-fields';
        
        // Enabled checkbox
        const enabledRow = document.createElement('div');
        enabledRow.className = 'lottie-interaction-field-row';
        const enabledCheckbox = document.createElement('input');
        enabledCheckbox.type = 'checkbox';
        enabledCheckbox.checked = interaction.enabled !== false;
        enabledCheckbox.addEventListener('change', function() {
            interactions[index].enabled = this.checked;
            markAsChanged();
        });
        const enabledLabel = document.createElement('label');
        enabledLabel.textContent = '{{ "Enabled"|t('craft-lottie') }}';
        enabledRow.appendChild(enabledCheckbox);
        enabledRow.appendChild(enabledLabel);
        fields.appendChild(enabledRow);
        
        // Type-specific fields
        switch (interaction.type) {
            case 'scroll':
                fields.appendChild(createSelectField('{{ "Trigger"|t('craft-lottie') }}', 'trigger', ['onScroll', 'onViewport', 'onScrollProgress'], interaction.trigger || 'onScroll', index));
                fields.appendChild(createNumberField('{{ "Offset"|t('craft-lottie') }}', 'offset', interaction.offset || 0, index, 0, 1, 0.1));
                fields.appendChild(createSelectField('{{ "Direction"|t('craft-lottie') }}', 'direction', ['forward', 'backward', 'both'], interaction.direction || 'forward', index));
                break;
            case 'click':
                fields.appendChild(createSelectField('{{ "Action"|t('craft-lottie') }}', 'action', ['play', 'pause', 'toggle', 'restart'], interaction.action || 'play', index));
                break;
            case 'hover':
                fields.appendChild(createSelectField('{{ "On Enter"|t('craft-lottie') }}', 'onEnter', ['play', 'pause', 'restart'], interaction.onEnter || 'play', index));
                fields.appendChild(createSelectField('{{ "On Leave"|t('craft-lottie') }}', 'onLeave', ['play', 'pause', 'restart'], interaction.onLeave || 'pause', index));
                break;
            case 'url':
                fields.appendChild(createTextField('{{ "URL"|t('craft-lottie') }}', 'url', interaction.url || '', index));
                fields.appendChild(createSelectField('{{ "Target"|t('craft-lottie') }}', 'target', ['_self', '_blank', '_parent', '_top'], interaction.target || '_self', index));
                fields.appendChild(createTextField('{{ "Layer Name"|t('craft-lottie') }}', 'layerName', interaction.layerName || '', index, '{{ "Optional: specific layer to make clickable"|t('craft-lottie') }}'));
                break;
        }
        
        item.appendChild(fields);
        const addBtn = document.getElementById('add-interaction-btn');
        if (addBtn) {
            interactionsContainer.insertBefore(item, addBtn);
        } else {
            interactionsContainer.appendChild(item);
        }
    }

    function createSelectField(label, fieldName, options, value, index) {
        const field = document.createElement('div');
        field.className = 'lottie-interaction-field';
        
        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        
        const select = document.createElement('select');
        options.forEach(opt => {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt;
            if (opt === value) option.selected = true;
            select.appendChild(option);
        });
        select.addEventListener('change', function() {
            interactions[index][fieldName] = this.value;
            markAsChanged();
        });
        
        field.appendChild(labelEl);
        field.appendChild(select);
        return field;
    }

    function createTextField(label, fieldName, value, index, placeholder = '') {
        const field = document.createElement('div');
        field.className = 'lottie-interaction-field';
        
        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        
        const input = document.createElement('input');
        input.type = 'text';
        input.value = value;
        input.placeholder = placeholder;
        input.addEventListener('input', function() {
            interactions[index][fieldName] = this.value;
            markAsChanged();
        });
        
        field.appendChild(labelEl);
        field.appendChild(input);
        return field;
    }

    function createNumberField(label, fieldName, value, index, min, max, step) {
        const field = document.createElement('div');
        field.className = 'lottie-interaction-field';
        
        const labelEl = document.createElement('label');
        labelEl.textContent = label;
        
        const input = document.createElement('input');
        input.type = 'number';
        input.value = value;
        input.min = min;
        input.max = max;
        input.step = step;
        input.addEventListener('input', function() {
            interactions[index][fieldName] = parseFloat(this.value) || 0;
            markAsChanged();
        });
        
        field.appendChild(labelEl);
        field.appendChild(input);
        return field;
    }

    function getInteractionTypeLabel(type) {
        const labels = {
            'scroll': '{{ "Scroll Trigger"|t('craft-lottie') }}',
            'click': '{{ "Click Action"|t('craft-lottie') }}',
            'hover': '{{ "Hover Effect"|t('craft-lottie') }}',
            'url': '{{ "URL Link"|t('craft-lottie') }}'
        };
        return labels[type] || type;
    }

    // Initialize interaction type menu - use a function that can be called after DOM is ready
    let menuBtn = null; // Store globally to prevent double-instantiation
    
    function initializeInteractionMenu() {
        const addInteractionBtn = document.getElementById('add-interaction-btn');
        
        if (!addInteractionBtn) {
            return;
        }
        
        // Prevent double-instantiation
        if (menuBtn || addInteractionBtn.hasAttribute('data-garnish-initialized')) {
            return;
        }
        
        if (addInteractionBtn) {
        
        // Function to add interaction
        function addInteraction(type) {
            if (!type || !['scroll', 'click', 'hover', 'url'].includes(type)) {
                return;
            }
            
            if (!interactions) {
                interactions = [];
            }
            
            const newInteraction = {
                type: type,
                enabled: true
            };
            
            interactions.push(newInteraction);
            renderInteractions();
            markAsChanged();
        }
        
        // Initialize Craft's menu button
        try {
            menuBtn = new Garnish.MenuBtn(addInteractionBtn, {
                onOptionSelect: function(option) {
                    // Get type from the option - it might be a DOM element or jQuery object
                    let type = null;
                    if (option && option.getAttribute) {
                        // It's a DOM element
                        type = option.getAttribute('data-type');
                    } else if (option && option.$option) {
                        // It's a jQuery-wrapped element
                        type = option.$option.getAttribute('data-type');
                    } else if (option && option.data) {
                        // It has a data method (jQuery)
                        type = option.data('type');
                    } else if (option && option.attr) {
                        // It has an attr method (jQuery)
                        type = option.attr('data-type');
                    }
                    if (type) {
                        addInteraction(type);
                    }
                }
            });
            
            // Mark as initialized to prevent double-instantiation
            addInteractionBtn.setAttribute('data-garnish-initialized', 'true');
            
            // Find the Garnish-created menu and populate it
            setTimeout(function() {
                const garnishMenuId = addInteractionBtn.getAttribute('aria-controls');
                
                if (garnishMenuId) {
                    const garnishMenu = document.getElementById(garnishMenuId);
                    if (garnishMenu) {
                        // Populate the menu with our items - use the labels defined at the top of the JS block
                        garnishMenu.innerHTML = '<ul class="padded">' +
                            '<li><a href="javascript:void(0)" data-type="scroll"><span class="icon" data-icon="arrows"></span> ' + scrollTriggerLabel + '</a></li>' +
                            '<li><a href="javascript:void(0)" data-type="click"><span class="icon" data-icon="pointer"></span> ' + clickActionLabel + '</a></li>' +
                            '<li><a href="javascript:void(0)" data-type="hover"><span class="icon" data-icon="cursor"></span> ' + hoverEffectLabel + '</a></li>' +
                            '<li><a href="javascript:void(0)" data-type="url"><span class="icon" data-icon="world"></span> ' + urlLinkLabel + '</a></li>' +
                            '</ul>';
                        
                        // Attach click handlers
                        const menuItems = garnishMenu.querySelectorAll('a[data-type]');
                        menuItems.forEach(function(item) {
                            item.addEventListener('click', function(e) {
                                const type = this.getAttribute('data-type');
                                addInteraction(type);
                                if (menuBtn) {
                                    menuBtn.hide();
                                }
                            });
                        });
                    }
                }
            }, 10);
        } catch (e) {
            console.error('Failed to initialize interaction menu:', e);
        }
        
        // No fallback needed - Garnish.MenuBtn handles everything via menuOptions
        }
    }
    
    // Try to initialize menu immediately
    initializeInteractionMenu();
    
    // Also try after a short delay in case DOM isn't ready
    setTimeout(function() {
        const btn = document.getElementById('add-interaction-btn');
        if (btn && !btn.hasAttribute('data-garnish-initialized')) {
            initializeInteractionMenu();
        }
    }, 100);
    
    // Re-initialize menu after renderInteractions in case it was removed
    const originalRenderInteractions = renderInteractions;
    renderInteractions = function() {
        originalRenderInteractions();
        // Re-initialize menu after rendering in case it was lost
        setTimeout(function() {
            const btn = document.getElementById('add-interaction-btn');
            // Only re-initialize if button exists and hasn't been initialized yet
            if (btn && !btn.hasAttribute('data-garnish-initialized')) {
                initializeInteractionMenu();
            }
        }, 50);
    };

    // Save button handler
    saveBtn.addEventListener('click', function() {
        if (!hasChanges) return;

        saveBtn.disabled = true;
        saveBtn.textContent = '{{ "Saving..."|t('craft-lottie') }}';

        // Create a clean copy for saving (remove internal flags, apply layer visibility)
        const dataToSave = JSON.parse(JSON.stringify(lottieData));
        
        // Apply layer visibility changes to the saved data
        if (dataToSave.layers && Array.isArray(dataToSave.layers)) {
            dataToSave.layers.forEach((layer, index) => {
                const originalLayer = lottieData.layers[index];
                if (originalLayer && originalLayer._hidden === true) {
                    // Hide layer by setting op to ip
                    const layerIp = layer.ip !== undefined ? layer.ip : 0;
                    layer.op = layerIp;
                }
                // Remove internal flags
                delete layer._hidden;
                delete layer._originalOp;
            });
        }
        
        // Clean all internal flags from the entire structure
        cleanLottieData(dataToSave);

        const formData = new FormData();
        formData.append('assetId', assetId);
        formData.append('jsonData', JSON.stringify(dataToSave));
        formData.append('backgroundColor', backgroundColor || '');
        formData.append('speed', speedControl.value || '1.0');
        formData.append('interactions', JSON.stringify(interactions || []));
        formData.append('{{ craft.app.request.csrfParam }}', '{{ craft.app.request.csrfToken }}');
        
        // Note: Text changes are already in lottieData from updateText() calls

        fetch('/actions/craft-lottie/default/save-asset-json', {
            method: 'POST',
            body: formData,
            headers: {
                'Accept': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`Server error: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                hasChanges = false;
                saveBtn.textContent = '{{ "Saved!"|t('craft-lottie') }}';
                setTimeout(() => {
                    saveBtn.textContent = '{{ "Save Changes"|t('craft-lottie') }}';
                    saveBtn.disabled = true;
                }, 2000);
                Craft.cp.displayNotice('{{ "Animation saved successfully"|t('craft-lottie') }}');
            } else {
                throw new Error(data.error || '{{ "Failed to save"|t('craft-lottie') }}');
            }
        })
        .catch(error => {
            console.error('Save failed:', error);
            saveBtn.disabled = false;
            saveBtn.textContent = '{{ "Save Changes"|t('craft-lottie') }}';
            Craft.cp.displayError('{{ "Failed to save animation:"|t('craft-lottie') }} ' + error.message);
        });
    });

    // Save as Copy button handler
    if (saveAsBtn) {
        saveAsBtn.addEventListener('click', function() {
        saveAsBtn.disabled = true;
        saveAsBtn.textContent = '{{ "Saving..."|t('craft-lottie') }}';

        // Create a clean copy for saving (remove internal flags, apply layer visibility)
        const dataToSave = JSON.parse(JSON.stringify(lottieData));
        
        // Apply layer visibility changes to the saved data
        if (dataToSave.layers && Array.isArray(dataToSave.layers)) {
            dataToSave.layers.forEach((layer, index) => {
                const originalLayer = lottieData.layers[index];
                if (originalLayer && originalLayer._hidden === true) {
                    // Hide layer by setting op to ip
                    const layerIp = layer.ip !== undefined ? layer.ip : 0;
                    layer.op = layerIp;
                }
                // Remove internal flags
                delete layer._hidden;
                delete layer._originalOp;
            });
        }
        
        // Clean all internal flags from the entire structure
        cleanLottieData(dataToSave);

        const formData = new FormData();
        formData.append('assetId', assetId);
        formData.append('jsonData', JSON.stringify(dataToSave));
        formData.append('backgroundColor', backgroundColor || '');
        formData.append('speed', speedControl.value || '1.0');
        formData.append('interactions', JSON.stringify(interactions || []));
        formData.append('{{ craft.app.request.csrfParam }}', '{{ craft.app.request.csrfToken }}');

        fetch('/actions/craft-lottie/default/save-as-new-asset', {
            method: 'POST',
            body: formData,
            headers: {
                'Accept': 'application/json'
            }
        })
        .then(response => {
            if (!response.ok) {
                return response.text().then(text => {
                    throw new Error(`Server error: ${response.status}`);
                });
            }
            return response.json();
        })
        .then(data => {
            if (data.success) {
                saveAsBtn.textContent = '{{ "Saved!"|t('craft-lottie') }}';
                setTimeout(() => {
                    saveAsBtn.textContent = '{{ "Save as Copy"|t('craft-lottie') }}';
                    saveAsBtn.disabled = false;
                }, 2000);
                Craft.cp.displayNotice('{{ "Animation saved as new asset successfully"|t('craft-lottie') }}');
                // Optionally redirect to the new asset
                if (data.assetId) {
                    setTimeout(() => {
                        window.location.href = '/admin/craft-lottie/edit/' + data.assetId;
                    }, 1500);
                }
            } else {
                throw new Error(data.error || '{{ "Failed to save as new asset"|t('craft-lottie') }}');
            }
        })
        .catch(error => {
            console.error('Save as new asset failed:', error);
            saveAsBtn.disabled = false;
            saveAsBtn.textContent = '{{ "Save as Copy"|t('craft-lottie') }}';
            Craft.cp.displayError('{{ "Failed to save as new asset:"|t('craft-lottie') }} ' + error.message);
        });
    });
    }
}
{% endjs %}
